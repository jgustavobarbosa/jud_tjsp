# -*- coding: utf-8 -*-
"""tratamento_dados_tjsp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mUotMKdnNrq0vl-tUpOkCIs5A1go_cLU
"""

from google.colab import drive
drive.mount('/content/drive')

"""##Analise de dados TJSP a partir do banco de sentenças coletados"""

#!pip install basedosdados
!pip install unidecode
!pip install folium
!pip install googlemaps
#!pip install nltk
#!pip install seaborn

import pandas as pd
import csv
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import folium
import googlemaps
import nltk
from nltk.corpus import stopwords
nltk.download('stopwords')
nltk.download('punkt')
import pandas as pd
from unidecode import unidecode
from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

"""##Lendo os dados baixados
###Verificando formatação da tabela
"""

with open('/content/tabelas_tjsp_medicamento_cancer.csv', 'r') as file:
    for _ in range(10):
        print(file.readline())

"""Colocando aspas para evitar erros de ler campos apenas com aspas abertas"""

csv.field_size_limit(10000000)  # Aumenta para 10 milhões, ajuste conforme necessário


# Caminho para o arquivo original e o novo arquivo
input_path = '/content/drive/MyDrive/pos_doc_usp/analise/tabelas_tjsp_medicamento_cancer.csv'
output_path = '/content/drive/MyDrive/pos_doc_usp/analise/tabelas_tjsp_medicamento_cancer_corrected.csv'

# Abrir o arquivo original para leitura e o novo arquivo para escrita
with open(input_path, mode='r', newline='', encoding='utf-8') as infile, \
     open(output_path, mode='w', newline='', encoding='utf-8') as outfile:
    reader = csv.reader(infile, delimiter=',', quotechar='"')
    writer = csv.writer(outfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)

    for row in reader:
        new_row = []
        for field in row:
            # Adiciona aspas se o campo contém uma vírgula e não está já entre aspas
            if ',' in field and not (field.startswith('"') and field.endswith('"')):
                new_row.append(f'"{field}"')
            else:
                new_row.append(field)
        writer.writerow(new_row)

# Agora tente ler o novo arquivo
import pandas as pd
tjsp = pd.read_csv(output_path, sep=',', quotechar='"')
print(tjsp.head())

"""### Analisando dados gerais do dataset"""

tjsp = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/tabelas_tjsp_medicamento_cancer_corrected.csv', sep=',', quotechar='"')

print(tjsp.shape)
print(tjsp.info())
#print(tjsp.describe())

"""##Retirando colunas não necessarias"""

tjsp.drop(['hora_coleta'], axis=1, inplace=True)
tjsp.columns

"""Corrigindo natureza do campo"""

# Exemplo de conversão de um campo para data
tjsp['disponibilizacao'] = pd.to_datetime(tjsp['disponibilizacao'], errors='coerce')

# Exemplo de conversão de um campo para numérico
# df['numeric_column'] = pd.to_numeric(df['numeric_column'], errors='coerce')

"""AED - geral

###Valores Unicos
"""

# Contagem de valores únicos para cada coluna
for column in tjsp.columns:
    print(f'{column}: {tjsp[column].nunique()} valores únicos')

# Frequências de valores para uma coluna específica
print(tjsp['comarca'].value_counts())
print(tjsp['magistrado'].value_counts())
print(tjsp['assunto'].value_counts())
print(tjsp['processo'].value_counts())

"""Distribuiçao dos processos por comarca"""

# Gráfico de barras das frequências de uma coluna específica
tjsp['comarca'].value_counts().head(20).plot(kind='bar')
plt.title('Distribuição de [comarca]')
plt.xlabel('Categoria')
plt.ylabel('Frequência')
plt.show()

"""Comparando com o tamanho dos municipios"""

# Tratando as colunas para remoção de acentos e conversão para caixa baixa
dados_processos['comarca'] = dados_processos['comarca'].astype(str).fillna('')
dados_processos['comarca'] = dados_processos['comarca'].apply(lambda x: unidecode(x.split('/')[0].strip()).lower())

dados_populacao['municipio'] = dados_populacao['municipio'].astype(str).fillna('')
dados_populacao['municipio'] = dados_populacao['municipio'].apply(lambda x: unidecode(x).lower())
dados_populacao['cod_ibge'] = dados_populacao['cod_ibge'].astype(str).fillna('')
dados_populacao['censo2022'] = dados_populacao['censo2022'].fillna(0)  # Supondo que `censo2022` é numérico

# Calculando a frequência dos processos por comarca
frequencia_processos = dados_processos['comarca'].value_counts().reset_index()
frequencia_processos.columns = ['comarca', 'frequencia']

# Combinando os dados de frequência de processos com os dados de população e município
dados_combinados = pd.merge(frequencia_processos, dados_populacao[['cod_ibge', 'municipio', 'censo2022']], left_on='comarca', right_on='municipio', how='left')

# Renomeando as colunas para clareza
dados_combinados = dados_combinados.rename(columns={'municipio': 'nome_municipio', 'censo2022': 'populacao'})

# Selecionando os top 20 municípios com mais frequência
top_20_municipios = dados_combinados.nlargest(20, 'frequencia')

# Verificando os dados combinados filtrados
print(top_20_municipios)

# Criando o gráfico de barras empilhadas dos top 20 municípios
fig, ax1 = plt.subplots(figsize=(14, 8))

# Gráfico de frequência de processos
ax1.bar(top_20_municipios['nome_municipio'], top_20_municipios['frequencia'], color='b', align='center', width=0.4)
ax1.set_xlabel('Município')
ax1.set_ylabel('Frequência de Processos', color='b')
ax1.tick_params('y', colors='b')

# Criando um segundo eixo y para o gráfico de população
ax2 = ax1.twinx()
ax2.plot(top_20_municipios['nome_municipio'], top_20_municipios['populacao'], color='r', marker='o', linestyle='-', linewidth=2)
ax2.set_ylabel('População', color='r')
ax2.tick_params('y', colors='r')

plt.title('Top 20 Municípios com Mais Frequência de Processos vs População')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Gráfico comparando a frequência de processos por comarca (top 20) com a população
plt.figure(figsize=(14, 8))
ax = top_20_municipios.plot(kind='bar', x='nome_municipio', y=['frequencia', 'populacao'], secondary_y='populacao', rot=45, width=0.4)
plt.title('Top 20 Municípios: Frequência de Processos vs População')
plt.xlabel('Município')
plt.tight_layout()
plt.show()

dados_populacao = pd.read_excel('/content/drive/MyDrive/pos_doc_usp/analise/censo2022_populacao.xlsx',)
dados_populacao.columns

"""Trata as colunas comarca e municipio para remover acentos e converter para caixa baixa.

Calcula a frequência dos processos por comarca.

Combina os dados de frequência com os dados de população e município.

Filtra os 50 municípios com a maior frequência de processos.

Cria um gráfico de barras empilhadas para mostrar a distribuição de processos por município versus a população para esses 50 municípios.
"""

# Carregando os dados de processos
dados_processos = tjsp[['comarca', 'magistrado']]

dados_processos['comarca'] = dados_processos['comarca'].astype(str).fillna('')
dados_processos['comarca'] = dados_processos['comarca'].apply(lambda x: unidecode(x).lower())
dados_processos['magistrado'] = dados_processos['magistrado'].astype(str).fillna('')
dados_processos['magistrado'] = dados_processos['magistrado'].apply(lambda x: unidecode(x).lower())
# Carregando os dados de população e município a partir de um arquivo local
dados_populacao = pd.read_excel('/content/drive/MyDrive/pos_doc_usp/analise/censo2022_populacao.xlsx')

dados_populacao['cod_ibge'] = dados_populacao['cod_ibge'].astype(str).fillna('')
dados_populacao['municipio'] = dados_populacao['municipio'].astype(str).fillna('')
dados_populacao['municipio'] = dados_populacao['municipio'].apply(lambda x: unidecode(x).lower())
dados_populacao['censo2022'] = dados_populacao['censo2022'].fillna(0)

# Calculando a frequência dos processos por comarca
frequencia_processos = dados_processos['comarca'].value_counts().reset_index()
frequencia_processos.columns = ['comarca', 'frequencia']

# Combinando os dados de frequência de processos com os dados de população e município
dados_combinados = pd.merge(frequencia_processos, dados_populacao[['cod_ibge', 'municipio', 'censo2022']], left_on='comarca', right_on='municipio', how='left')

# Renomeando as colunas para clareza
dados_combinados = dados_combinados.rename(columns={'municipio': 'nome_municipio', 'censo2022': 'populacao'})

# Verificando se as colunas renomeadas existem
print(dados_combinados)

# Certificando-se de que as colunas necessárias estão presentes antes de criar o gráfico
if 'frequencia' in dados_combinados.columns and 'populacao' in dados_combinados.columns:
    # Criando o gráfico de barras empilhadas
    ax = dados_combinados.set_index('nome_municipio')[['frequencia', 'populacao']].plot(kind='bar', figsize=(12, 6), stacked=True)
    plt.title('Distribuição de Processos por Município vs População')
    plt.xlabel('Município')
    plt.ylabel('Frequência / População')
    plt.legend(['Frequência de Processos', 'População'])
    plt.xticks(rotation=90)
    plt.show()
else:
    print("Colunas 'frequencia' ou 'populacao' não encontradas nos dados combinados.")

# Selecionando os top 20 municípios com mais frequência
top_20_municipios = dados_combinados.nlargest(20, 'frequencia')

# Verificando os dados combinados filtrados
#rint(top_50_municipios)

# Criando o gráfico de barras empilhadas dos top 50 municípios
graf_top_20 = top_20_municipios.set_index('nome_municipio')[['frequencia', 'populacao']].plot(kind='bar', figsize=(12, 6), stacked=True)
plt.title('Top 50 Municípios com Mais Frequência de Processos vs População')
plt.xlabel('Município')
plt.ylabel('Frequência / População')
plt.legend(['Frequência de Processos', 'População'])
plt.xticks(rotation=90)
plt.show()

dados_combinados.head()

dados_populacao = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/municipio.csv')
dados_populacao.columns

"""##Limpeza dos dados de julgados para fazer um topic modeling"""

# Carregar stopwords em português (ajuste para o idioma apropriado)
stop_words = set(stopwords.words('portuguese'))

def clean_text(text):
    # Tokenizar o texto e converter para letras minúsculas
    words = nltk.word_tokenize(text.lower())
    # Filtrar stopwords, preposições e conjunções
    filtered_words = [word for word in words if word.isalpha() and word not in stop_words]
    return " ".join(filtered_words)

# Aplicar a função de limpeza na coluna de texto
tjsp['julgado'] = tjsp['julgado'].apply(clean_text)

tjsp.to_csv('/content/drive/MyDrive/pos_doc_usp/analise/tabelas_tjsp_medicamento_corrigido.csv', index=False)

# Contar palavras após a limpeza
word_counts = tjsp['julgado'].str.split().explode().value_counts()

# Plotar as palavras mais comuns
word_counts.head(20).plot(kind='bar')
plt.title('Top 20 palavras mais frequentes após remoção de stopwords')
plt.xlabel('Palavra')
plt.ylabel('Frequência')
plt.show()

# Contagem de palavras em um campo de texto
tjsp['julgado'].str.split().explode().value_counts().head(20).plot(kind='bar')
plt.title('Top 20 palavras mais frequentes em [texto_column]')
plt.xlabel('Palavra')
plt.ylabel('Frequência')
plt.show()

"""## Plotando os mapas"""

# Carregar os dados
df = pd.read_csv("/content/drive/MyDrive/pos_doc_usp/analise/tabelas_tjsp_medicamento_corrigido.csv")

# Supondo que 'comarca' é a coluna para município e 'assunto' para categorizar processos
print(df[['comarca', 'assunto']].head())

df.columns

"""###Categorizando processos por assunto"""

# Contar processos por assunto em cada município
process_count = df.groupby(['comarca', 'assunto', 'magistrado']).size().reset_index(name='count')

# Truncar os valores na coluna 'assunto' para no máximo 35 caracteres
process_count['assunto'] = process_count['assunto'].apply(lambda x: x[:35])

print(process_count.head())

process_count = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv')

"""# 3. Preparar os Dados para Mapeamento geral - graph base



"""



# Inicializar o cliente do Google Maps
#gmaps = googlemaps.Client(key='AIzaSyAvqU8-togmlAdibLlfdz6YpgN5cVD7d54')

# Função para obter coordenadas com condição de fallback

#def get_coordinates(city):
#    try:
        # Primeira tentativa: Procurar o município no estado de São Paulo, Brasil
#        geocode_result = gmaps.geocode(f"{city}, São Paulo, Brazil")
#        if not geocode_result:  # Se não encontrar resultados, tentar sem especificar o estado
#            geocode_result = gmaps.geocode(f"{city}, Brazil")
#        if geocode_result:  # Se houver algum resultado, usar o primeiro
#            lat = geocode_result[0]['geometry']['location']['lat']
#            lng = geocode_result[0]['geometry']['location']['lng']
#            return (lat, lng)
#    except Exception as e:
#        print(f"Error fetching coordinates for {city}: {str(e)}")
#    return None
# Aplicar a função em cada município
#process_count['coordinates'] = process_count['comarca'].apply(get_coordinates)

#process_count.to_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv', index=False)

print(process_count.head())
print(process_count.shape)



"""## Tratando as coordenadas para quando houver split o formato ser identificado nao como um float mas como string, em função da tupla usada"""

# Converter a coluna de coordenadas para listas de floats [latitude, longitude]
def convert_coordinates(coord):
    try:
        if isinstance(coord, str):
            coord = coord.strip('()').replace(' ', '')  # Remover parênteses e espaços em branco
            return [float(x) for x in coord.split(',') if x]
        elif isinstance(coord, (tuple, list)) and len(coord) == 2:
            return [float(x) for x in coord]
    except ValueError:
        return None
    return None

process_count['coordinates'] = process_count['coordinates'].apply(convert_coordinates)

# Verificação dos dados convertidos
print(process_count)

# Criar mapa base
mapa = folium.Map(location=[-15.788497, -47.879873], zoom_start=5)  # Coordenadas do Brasil

# Adicionar pontos ao mapa
for idx, row in process_count.iterrows():
    if row['coordinates']:
        folium.CircleMarker(
            location=row['coordinates'],
            radius=row['count'] / 10,  # Ajustar o tamanho do círculo baseado no número de processos
            popup=f"{row['comarca']}: {row['assunto']} ({row['count']} processos)",
            color='blue',
            fill=True,
            fill_color='blue'
        ).add_to(mapa)

# Exibir mapa
mapa.save('/content/drive/MyDrive/pos_doc_usp/analise/mapa1.html')
print("Mapa salvo como 'mapa1.html'")

mapa

"""##Categorizando por tipo de assunto para plotagem

## Categorizar Formas por Magistrado
### trabalhando nos agrupamentos

## Ranqueando os magistrados
"""

# Agrupar por cidade e magistrado e somar os processos
magistrado_cidade = process_count.groupby(['comarca', 'magistrado']).sum().reset_index()

# Selecionar a primeira ocorrência de coordenadas para cada magistrado
first_coordinates = process_count.groupby('magistrado')['coordinates'].first().reset_index()

# Unir as coordenadas únicas ao DataFrame de magistrados
magistrado_cidade = magistrado_cidade.merge(first_coordinates, on='magistrado')

# Ordenar os resultados pelo número de processos e selecionar os top 50 magistrados
top_magistrados = magistrado_cidade.sort_values(by='count', ascending=False).head(50)

# Truncar os valores na coluna 'assunto' para no máximo 35 caracteres
top_magistrados['assunto'] = top_magistrados['assunto'].apply(lambda x: x[:35] if isinstance(x, str) else x)

top_magistrados.drop(columns=['coordinates_x'], inplace=True)

# Recriar o dicionário após a truncagem
unique_assuntos = top_magistrados['assunto'].unique()
colors = sns.color_palette('hsv', len(unique_assuntos)).as_hex()
assunto_to_color = dict(zip(unique_assuntos, colors))

top_magistrados.rename(columns={'coordinates_y': 'coordinates'}, inplace=True)

print(top_magistrados.head())
print(unique_assuntos)

def convert_coordinates(coord):
    try:
        if isinstance(coord, str):
            coord = coord.strip('()').replace(' ', '')  # Remover parênteses e espaços em branco
            return [float(x) for x in coord.split(',') if x]
        elif isinstance(coord, (tuple, list)) and len(coord) == 2:
            return [float(x) for x in coord]
    except ValueError:
        return None
    return None

top_magistrados['coordinates'] = top_magistrados['coordinates'].apply(convert_coordinates)

# Verificação dos dados convertidos
print(top_magistrados)

top_magistrados.info()

"""## Importante:Os números  gerados pelo MarkerCluster do Folium, indicam quantos marcadores foram agrupados naquela área específica.

O MarkerCluster ajuda a manter o mapa legível quando há muitos pontos próximos uns dos outros, agrupando-os em um único marcador até que você faça zoom suficiente para ver os marcadores individuais.
"""

from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp = folium.Map(location=centro_sp, zoom_start=7)
marker_cluster = MarkerCluster().add_to(mapa_sp)

# Criar FeatureGroups para magistrados
magistrado_groups = {}

# Adicionando FeatureGroups ao mapa
for idx, row in top_magistrados.iterrows():
    magistrado = row['magistrado']
    coords = row['coordinates']
    if coords and len(coords) == 2:
        # Adicionar marcadores ao mapa
        marker = folium.CircleMarker(
            location=coords,
            radius=row['count'] / 10,
            popup=f"{row['comarca']}: {row['assunto']} ({row['count']} processos), Magistrado: {magistrado}",
            color='blue',  # Cor padrão
            fill=True,
            fill_color='blue'
        )
        marker.add_to(marker_cluster)

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp)

# Salvar e mostrar o mapa
#mapa_sp.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_sao_paulo.html')
print("Mapa salvo como 'interactive_map_sao_paulo.html'")

mapa_sp

municipio = pd.read_excel('/content/drive/MyDrive/pos_doc_usp/analise/divisoes_regionais_esp.xlsx')

municipio.head()

mapa_sp

"""##Geração de mapas por magistrado x municipio x processos"""

# Agrupar por cidade e magistrado e somar os processos
magistrado_cidade = process_count.groupby(['comarca', 'magistrado']).sum().reset_index()

# Selecionar a primeira ocorrência de coordenadas para cada magistrado
first_coordinates = process_count.groupby('magistrado')['coordinates'].first().reset_index()

# Unir as coordenadas únicas ao DataFrame de magistrados
magistrado_cidade = magistrado_cidade.merge(first_coordinates, on='magistrado')

# Ordenar os resultados pelo número de processos e selecionar os top 50 magistrados
top_magistrados = magistrado_cidade.sort_values(by='count', ascending=False).head(50)

# Truncar os valores na coluna 'assunto' para no máximo 35 caracteres
top_magistrados['assunto'] = top_magistrados['assunto'].apply(lambda x: x[:35] if isinstance(x, str) else x)

# Remover colunas duplicadas, se houver
if 'coordinates_x' in top_magistrados.columns:
    top_magistrados.drop(columns=['coordinates_x'], inplace=True)

# Recriar o dicionário após a truncagem
unique_assuntos = top_magistrados['assunto'].unique()
colors = sns.color_palette('hsv', len(unique_assuntos)).as_hex()
assunto_to_color = dict(zip(unique_assuntos, colors))

# Verificação dos dados finais
print(top_magistrados)

import pandas as pd
import folium
from folium.plugins import MarkerCluster
from folium import LayerControl, FeatureGroup
import seaborn as sns
import ast
# Converter a coluna de coordenadas para strings no formato "latitude,longitude"
def convert_coordinates(coord):
    if isinstance(coord, str):
        return coord.strip('[]')
    elif isinstance(coord, (tuple, list)) and len(coord) == 2:
        return f"{coord[0]},{coord[1]}"
    return None

process_count['coordinates'] = process_count['coordinates'].apply(convert_coordinates)

# Verificação dos dados convertidos
print(process_count.head())

# Agrupar por cidade, assunto e coordenadas e somar os processos
cidade_assunto_coord = process_count.groupby(['comarca', 'assunto', 'coordinates']).sum().reset_index()

# Ordenar os resultados pelo número de processos e selecionar os top 50 cidades
top_cidades = cidade_assunto_coord.sort_values(by='count', ascending=False).head(50)

# Truncar os valores na coluna 'assunto' para no máximo 35 caracteres
top_cidades['assunto'] = top_cidades['assunto'].apply(lambda x: x[:35] if isinstance(x, str) else x)

# Recriar o dicionário após a truncagem
unique_assuntos = top_cidades['assunto'].unique()
colors = sns.color_palette('hsv', len(unique_assuntos)).as_hex()
assunto_to_color = dict(zip(unique_assuntos, colors))

# Verificação dos dados finais
print(top_cidades.head())

#

"""### tentativa de plotagem de magistrados por municipio, por assunto"""

import pandas as pd
import folium
from folium.plugins import MarkerCluster
from folium import LayerControl, FeatureGroup
import ast

# Carregar dados do CSV
process_count = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv')

# Converter a coluna de coordenadas para listas de floats
def convert_coordinates(coord):
    try:
        return ast.literal_eval(coord)
    except (ValueError, SyntaxError):
        return None

process_count['coordinates'] = process_count['coordinates'].apply(convert_coordinates)

# Remover linhas com coordenadas inválidas
process_count = process_count.dropna(subset=['coordinates'])

# Agrupar dados por comarca, assunto e coordenadas
grouped = process_count.groupby(['comarca', 'assunto', 'coordinates']).agg({'count': 'sum'}).reset_index()

# Verificação dos dados convertidos
print(grouped.head())

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base
mapa_sp = folium.Map(location=centro_sp, zoom_start=7)
marker_cluster = MarkerCluster().add_to(mapa_sp)

# Função para adicionar marcadores ao mapa com base nos filtros
def adicionar_marcadores(df, assunto_selecionado=None, municipio_selecionado=None):
    for idx, row in df.iterrows():
        assunto = row['assunto']
        municipio = row['comarca']
        coords = row['coordinates']

        if ((assunto_selecionado is None or assunto in assunto_selecionado) and
            (municipio_selecionado is None or municipio in municipio_selecionado)):

            folium.Marker(
                location=coords,
                popup=f"{municipio}: {assunto} ({row['count']} processos)",
                tooltip=f"{municipio}: {assunto}",
                icon=folium.Icon(color='blue', icon='info-sign')
            ).add_to(marker_cluster)

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp)

# Função para mostrar o mapa no Jupyter Notebook
def exibir_mapa(mapa):
    import IPython
    from IPython.display import display

    mapa.save("mapa_interativo.html")
    display(IPython.display.IFrame("mapa_interativo.html", width=700, height=500))

# Função para atualizar o mapa com novos filtros
def atualizar_mapa(assunto=None, municipio=None):
    mapa_sp = folium.Map(location=centro_sp, zoom_start=7)
    marker_cluster = MarkerCluster().add_to(mapa_sp)
    adicionar_marcadores(grouped, assunto, municipio)
    LayerControl(collapsed=False).add_to(mapa_sp)
    exibir_mapa(mapa_sp)

# Interface simples para selecionar filtros e atualizar o mapa
import ipywidgets as widgets
from ipywidgets import interact

assuntos = process_count['assunto'].unique().tolist()
municipios = process_count['comarca'].unique().tolist()

interact(atualizar_mapa,
         assunto=widgets.SelectMultiple(options=assuntos, description='Assunto:', disabled=False),
         municipio=widgets.SelectMultiple(options=municipios, description='Município:', disabled=False))

import folium
import pandas as pd
from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

# Carregar dados do arquivo CSV
#process_count = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv')
process_count = top_cidades
# Converter a coluna de coordenadas para strings no formato "latitude,longitude"
def convert_coordinates(coord):
    if isinstance(coord, str):
        coord = coord.strip('()')  # Remove os parênteses
        return coord.strip('[]')
    elif isinstance(coord, (tuple, list)) and len(coord) == 2:
        return f"{coord[0]},{coord[1]}"
    return None

process_count['coordinates'] = process_count['coordinates'].apply(convert_coordinates)

# Verificação dos dados convertidos
print(process_count.head())

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_mag = folium.Map(location=centro_sp, zoom_start=7)
marker_cluster = MarkerCluster().add_to(mapa_sp_mag)

# Criar FeatureGroups para assuntos, municípios e magistrados
assunto_groups = {}
municipio_groups = {}
magistrado_groups = {}

# Adicionar FeatureGroups ao mapa
for idx, row in process_count.iterrows():
    assunto = row['assunto']
    municipio = row['comarca']
    magistrado = row['magistrado'] if 'magistrado' in row else 'Desconhecido'
    coords = [float(coord) for coord in row['coordinates'].strip('()').split(',')]

    # Verificar se os grupos já existem, caso contrário, criar novos grupos
    if assunto not in assunto_groups:
        assunto_groups[assunto] = FeatureGroup(name=f"Assunto: {assunto}", show=False).add_to(mapa_sp_mag)
    if municipio not in municipio_groups:
        municipio_groups[municipio] = FeatureGroup(name=f"Município: {municipio}", show=False).add_to(mapa_sp_mag)
    if magistrado not in magistrado_groups:
        magistrado_groups[magistrado] = FeatureGroup(name=f"Magistrado: {magistrado}", show=False).add_to(mapa_sp_mag)

    # Adicionar marcadores a cada grupo
    marker = folium.CircleMarker(
        location=coords,
        radius=row['count'] / 10,
        popup=f"{municipio}: {assunto} ({row['count']} processos)",
        color='blue',  # Pode ajustar a cor conforme necessário
        fill=True,
        fill_color='blue'
    )
    marker.add_to(assunto_groups[assunto])
    marker.add_to(municipio_groups[municipio])
    marker.add_to(magistrado_groups[magistrado])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_mag)

# Salvar e mostrar mapa
mapa_sp_mag.save('/content/drive/MyDrive/pos_doc_usp/analise/mapa_sp_magistrado_interactive_map_sao_paulo.html')
print("Mapa salvo como 'interactive_map_sao_paulo.html'")

!pip install dash
!pip install dash_leaflet
!pip install ast
!pip install dash==2.3.1 dash-leaflet==0.1.17 pandas pyngrok
#!pip install pyngrok
!pip install ngrok

mapa_sp_mag

import dash
from dash import dcc, html, Input, Output
import dash_leaflet as dl
import pandas as pd
import ast
from pyngrok import ngrok

# Carregar dados do arquivo CSV
process_count = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv')

# Converter a coluna de coordenadas para listas
process_count['coordinates'] = process_count['coordinates'].apply(ast.literal_eval)

# Inicializar a aplicação Dash
app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1("Mapa Interativo de Processos"),
    dcc.Dropdown(
        id='magistrado-dropdown',
        options=[{'label': mag, 'value': mag} for mag in process_count['magistrado'].unique()],
        multi=True,
        placeholder="Selecione o Magistrado"
    ),
    dcc.Dropdown(
        id='municipio-dropdown',
        multi=True,
        placeholder="Selecione o Município"
    ),
    dcc.Dropdown(
        id='assunto-dropdown',
        multi=True,
        placeholder="Selecione o Assunto"
    ),
    dl.Map(center=[-23.550520, -46.633308], zoom=7, id='mapa', children=[
        dl.TileLayer()
    ])
])

@app.callback(
    Output('municipio-dropdown', 'options'),
    Input('magistrado-dropdown', 'value')
)
def set_municipios_options(selected_magistrados):
    if selected_magistrados:
        filtered = process_count[process_count['magistrado'].isin(selected_magistrados)]
        municipios = [{'label': mun, 'value': mun} for mun in filtered['comarca'].unique()]
        return municipios
    return []

@app.callback(
    Output('assunto-dropdown', 'options'),
    Input('magistrado-dropdown', 'value'),
    Input('municipio-dropdown', 'value')
)
def set_assuntos_options(selected_magistrados, selected_municipios):
    filtered = process_count.copy()
    if selected_magistrados:
        filtered = filtered[filtered['magistrado'].isin(selected_magistrados)]
    if selected_municipios:
        filtered = filtered[filtered['comarca'].isin(selected_municipios)]
    assuntos = [{'label': ass, 'value': ass} for ass in filtered['assunto'].unique()]
    return assuntos

@app.callback(
    Output('mapa', 'children'),
    Input('magistrado-dropdown', 'value'),
    Input('municipio-dropdown', 'value'),
    Input('assunto-dropdown', 'value')
)
def update_map(selected_magistrados, selected_municipios, selected_assuntos):
    filtered = process_count.copy()
    if selected_magistrados:
        filtered = filtered[filtered['magistrado'].isin(selected_magistrados)]
    if selected_municipios:
        filtered = filtered[filtered['comarca'].isin(selected_municipios)]
    if selected_assuntos:
        filtered = filtered[filtered['assunto'].isin(selected_assuntos)]

    markers = [dl.TileLayer()]
    for _, row in filtered.iterrows():
        marker = dl.Marker(position=row['coordinates'], children=[
            dl.Tooltip(f"{row['comarca']}: {row['count']} processos"),
            dl.Popup(html.Div([
                html.H3(f"Magistrado: {row['magistrado']}"),
                html.P(f"Município: {row['comarca']}"),
                html.P(f"Assunto: {row['assunto']}"),
                html.P(f"Processos: {row['count']}")
            ]))
        ])
        markers.append(marker)
    return markers

# Rodar a aplicação Dash usando ngrok
port = 8050
ngrok.set_auth_token("2gpCwAQh8EBka2ZY8BvvEZeIQ2i_6tPFrRMyBkvdaTFR8coHF")  # Substitua pelo seu token do ngrok
public_url = ngrok.connect(port).public_url
print(f'Public URL: {public_url}')

app.run_server(port=port, debug=True)

import folium
import pandas as pd
from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

# Carregar dados do arquivo CSV
municipios_df = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/municipio.csv')
process_count = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv')

# Definir centro aproximado do mapa
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base
mapa_sp_mag = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar dados por magistrado, município e assunto
grouped = process_count.groupby(['magistrado', 'comarca', 'assunto']).agg({'count': 'sum', 'coordinates': 'first'}).reset_index()

# Criar dicionários de FeatureGroups
magistrado_groups = {mag: FeatureGroup(name=f"Magistrado: {mag}", show=False) for mag in grouped['magistrado'].unique()}
municipio_groups = {mun: FeatureGroup(name=f"Município: {mun}", show=False) for mun in grouped['comarca'].unique()}
assunto_groups = {ass: FeatureGroup(name=f"Assunto: {ass}", show=False) for ass in grouped['assunto'].unique()}

# Adicionar FeatureGroups ao mapa
for fg in magistrado_groups.values():
    fg.add_to(mapa_sp_mag)
for fg in municipio_groups.values():
    fg.add_to(mapa_sp_mag)
for fg in assunto_groups.values():
    fg.add_to(mapa_sp_mag)

# Adicionar marcadores ao mapa
for idx, row in grouped.iterrows():
    coords = eval(row['coordinates'])  # Converter string de coordenadas para tupla
    folium.Marker(
        location=coords,
        popup=f"Magistrado: {row['magistrado']}<br>Município: {row['comarca']}<br>Assunto: {row['assunto']}<br>Processos: {row['count']}",
        tooltip=f"{row['comarca']}: {row['count']} processos",
        icon=folium.Icon(color='blue', icon='info-sign')
    ).add_to(magistrado_groups[row['magistrado']])
    folium.Marker(
        location=coords,
        popup=f"Magistrado: {row['magistrado']}<br>Município: {row['comarca']}<br>Assunto: {row['assunto']}<br>Processos: {row['count']}",
        tooltip=f"{row['comarca']}: {row['count']} processos",
        icon=folium.Icon(color='green', icon='info-sign')
    ).add_to(municipio_groups[row['comarca']])
    folium.Marker(
        location=coords,
        popup=f"Magistrado: {row['magistrado']}<br>Município: {row['comarca']}<br>Assunto: {row['assunto']}<br>Processos: {row['count']}",
        tooltip=f"{row['comarca']}: {row['count']} processos",
        icon=folium.Icon(color='red', icon='info-sign')
    ).add_to(assunto_groups[row['assunto']])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_mag)

# Salvar e mostrar o mapa
mapa_sp_mag.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_processos.html')
print("Mapa salvo como 'interactive_map_processos.html'")

mapa_sp_mag

import dash
from dash import dcc, html, Input, Output
import dash_leaflet as dl
import pandas as pd

municipios_df = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/municipio.csv')
process_count = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/analise/process_count.csv')



# Agrupar dados por magistrado, município e assunto
grouped = process_count.groupby(['magistrado', 'comarca', 'assunto']).agg({'count': 'sum', 'coordinates': 'first'}).reset_index()

# Inicializar o aplicativo Dash
app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1("Mapa Interativo de Processos"),
    dcc.Dropdown(
        id='magistrado-dropdown',
        options=[{'label': mag, 'value': mag} for mag in grouped['magistrado'].unique()],
        multi=False,
        placeholder="Selecione o Magistrado"
    ),
    dcc.Dropdown(
        id='municipio-dropdown',
        multi=False,
        placeholder="Selecione o Município"
    ),
    dcc.Dropdown(
        id='assunto-dropdown',
        multi=False,
        placeholder="Selecione o Assunto"
    ),
    dl.Map(center=[-23.550520, -46.633308], zoom=7, id='mapa', children=[
        dl.TileLayer()
    ]),
    dcc.Store(id='filtered-data')
])

@app.callback(
    Output('municipio-dropdown', 'options'),
    Output('municipio-dropdown', 'value'),
    Input('magistrado-dropdown', 'value')
)
def set_municipios_options(selected_magistrado):
    if selected_magistrado:
        filtered = grouped[grouped['magistrado'] == selected_magistrado]
        municipios = [{'label': mun, 'value': mun} for mun in filtered['comarca'].unique()]
        return municipios, None
    return [], None

@app.callback(
    Output('assunto-dropdown', 'options'),
    Output('assunto-dropdown', 'value'),
    Input('magistrado-dropdown', 'value'),
    Input('municipio-dropdown', 'value')
)
def set_assuntos_options(selected_magistrado, selected_municipio):
    if selected_magistrado and selected_municipio:
        filtered = grouped[(grouped['magistrado'] == selected_magistrado) & (grouped['comarca'] == selected_municipio)]
        assuntos = [{'label': ass, 'value': ass} for ass in filtered['assunto'].unique()]
        return assuntos, None
    return [], None

@app.callback(
    Output('filtered-data', 'data'),
    Input('magistrado-dropdown', 'value'),
    Input('municipio-dropdown', 'value'),
    Input('assunto-dropdown', 'value')
)
def filter_data(selected_magistrado, selected_municipio, selected_assunto):
    filtered = grouped.copy()
    if selected_magistrado:
        filtered = filtered[filtered['magistrado'] == selected_magistrado]
    if selected_municipio:
        filtered = filtered[filtered['comarca'] == selected_municipio]
    if selected_assunto:
        filtered = filtered[filtered['assunto'] == selected_assunto]
    return filtered.to_dict('records')

@app.callback(
    Output('mapa', 'children'),
    Input('filtered-data', 'data')
)
def update_map(data):
    markers = [dl.TileLayer()]
    for row in data:
        coords = eval(row['coordinates'])
        marker = dl.Marker(position=coords, children=[
            dl.Tooltip(f"{row['comarca']}: {row['count']} processos"),
            dl.Popup(html.Div([
                html.H3(f"Magistrado: {row['magistrado']}"),
                html.P(f"Município: {row['comarca']}"),
                html.P(f"Assunto: {row['assunto']}"),
                html.P(f"Processos: {row['count']}")
            ]))
        ])
        markers.append(marker)
    return markers

if __name__ == '__main__':
    app.run_server(debug=True)

# Mapeamento de magistrados para formas
magistrados = top_magistrados['magistrado'].unique()
shapes = ['circle', 'triangle', 'square', 'star', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon',
          'diamond', 'heart', 'club', 'spade', 'oval', 'egg', 'teardrop', 'crescent', 'cross', 'plus',
          'x', 'arrow', 'chevron', 'parallelogram', 'trapezoid', 'kite', 'semicircle', 'quartercircle', 'ring',
          'arc', 'pie', 'pacman', 'infinity', 'cloverleaf', 'fisheye', 'roundedsquare', 'roundedrectangle',
          'ellipse', 'bean', 'guitar', 'raindrop', 'cloud', 'moon', 'sun', 'snowflake', 'leaf', 'flower',
          'astroid', 'batsymbol', 'bolt', 'flag']
magistrado_to_shape = dict(zip(magistrados, shapes))

municipio.head()

"""## Integrar o arquivo CSV fornecido com as coordenadas dos municípios e agrupar os municípios por Região Administrativa (RA).

###Cada RA terá uma cor diferente, e os pontos serão conectados dentro de cada RA.

###Adicionaremos um filtro para permitir que o usuário selecione a RA que deseja visualizar no mapa.

Funções

. Carregar o arquivo CSV com os dados dos municípios e suas coordenadas.

. Agrupar os municípios por RA e definir cores para cada RA.

. Adicionar marcadores e polígonos ao mapa para cada RA.

. Adicionar um controle de camadas para filtrar por RA.

## repetindo mapa com as formas dos magistrados
"""

# Carregar dados do arquivo CSV
#file_path = '/mnt/data/divisoes_regionais_esp.csv'
municipios_df = municipio
# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_drs = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar os municípios por RA e definir cores para cada RA
ras = municipios_df['Cod_RA'].unique()
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'brown', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']

ra_colors = {ra: colors[i % len(colors)] for i, ra in enumerate(ras)}

# Criar FeatureGroups para cada RA
feature_groups = {ra: FeatureGroup(name=f"RA {ra}", show=False) for ra in ras}

# Adicionar FeatureGroups ao mapa
for fg in feature_groups.values():
    fg.add_to(mapa_sp_drs)

# Adicionar marcadores e polígonos ao mapa
for ra, group in municipios_df.groupby('Cod_RA'):
    coords = group[['Latitude', 'Longitude']].values.tolist()
    folium.Polygon(
        locations=coords,
        popup=f"RA {ra}",
        color=ra_colors[ra],
        fill=True,
        fill_color=ra_colors[ra],
        fill_opacity=0.4
    ).add_to(feature_groups[ra])

    for idx, row in group.iterrows():
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['Município']}: {row['Cod_RA']}",
            icon=folium.Icon(color='blue', icon='info-sign')
        ).add_to(feature_groups[ra])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_drs)

# Salvar e mostrar o mapa
mapa_sp_drs.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_drs.html')
print("Mapa salvo como 'interactive_map_dri.html'")

mapa_sp_drs

import folium
import pandas as pd
from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

# Carregar dados do arquivo CSV

municipios_df = municipio

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_map_dri = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar os municípios por RA e definir cores para cada RA
ras = municipios_df['Região Administrativa'].unique()
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'brown', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']

ra_colors = {ra: colors[i % len(colors)] for i, ra in enumerate(ras)}

# Criar FeatureGroups para cada RA
feature_groups = {ra: FeatureGroup(name=f"Região Administrativa: {ra}", show=False) for ra in ras}

# Adicionar FeatureGroups ao mapa
for fg in feature_groups.values():
    fg.add_to(mapa_sp_map_dri)

# Adicionar marcadores e polígonos ao mapa
for ra, group in municipios_df.groupby('Região Administrativa'):
    coords = group[['Latitude', 'Longitude']].values.tolist()
    folium.Polygon(
        locations=coords,
        popup=f"Região Administrativa: {ra}",
        color=ra_colors[ra],
        fill=True,
        fill_color=ra_colors[ra],
        fill_opacity=0.4
    ).add_to(feature_groups[ra])

    for idx, row in group.iterrows():
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['Município']}: {row['Cod_RA']}",
            tooltip=f"População 2020: {row['População 2020']}",
            icon=folium.Icon(color='blue', icon='info-sign')
        ).add_to(feature_groups[ra])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_map_dri)

# Salvar e mostrar o mapa
mapa_sp_map_dri.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_dri.html')
print("Mapa salvo como 'interactive_map_dri.html'")

"""Mapa regiao adminsitrativa"""

mapa_sp_map_dri

"""##Zoom apenas no mapa de sao paulo##"""

!pip install docx
!pip install Document
!pip install python-docx

municipio

import pandas as pd
import folium
from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

# Carregar dados do arquivo CSV
municipios_df = municipio

# Definir os municípios por DRS diretamente no código

drs_data = {
   'drs1': ["ARUJÁ", "BARUERI", "BIRITIBA-MIRIM", "CAIEIRAS", "CAJAMAR", "CARAPICUÍBA", "COTIA", "DIADEMA", "EMBU", "EMBU-GUAÇU", "FERRAZ DE VASCONCELOS", "FRANCISCO MORATO", "FRANCO DA ROCHA", "GUARAREMA", "GUARULHOS", "ITAPECERICA DA SERRA", "ITAPEVI", "ITAQUAQUECETUBA", "JANDIRA", "JUQUITIBA", "MAIRIPORÃ", "MAUÁ", "MOGI DAS CRUZES", "OSASCO", "PIRAPORA DO BOM JESUS", "POÁ", "RIBEIRÃO PIRES", "RIO GRANDE DA SERRA", "SALESÓPOLIS", "SANTA ISABEL", "SANTANA DE PARNAÍBA", "SANTO ANDRÉ", "SÃO BERNARDO DO CAMPO", "SÃO CAETANO DO SUL", "SÃO LOURENÇO DA SERRA", "SÃO PAULO", "SUZANO", "TABOÃO DA SERRA", "VARGEM GRANDE PAULISTA"],
   'drs2_araçatuba': ["ALTO ALEGRE", "ANDRADINA", "ARAÇATUBA", "AURIFLAMA", "AVANHANDAVA", "BARBOSA", "BENTO DE ABREU", "BILAC", "BIRIGUI", "BRAÚNA", "BREJO ALEGRE", "BURITAMA", "CASTILHO", "CLEMENTINA", "COROADOS", "GABRIEL MONTEIRO", "GLICÉRIO", "GUARAÇAÍ", "GUARARAPES", "GUZOLÂNDIA", "ILHA SOLTEIRA", "ITAPURA", "LAVÍNIA", "LOURDES", "LUIZIÂNIA", "MIRANDÓPOLIS", "MURUTINGA DO SUL", "NOVA CASTILHO", "NOVA INDEPENDÊNCIA", "NOVA LUZITÂNIA", "PENÁPOLIS", "PEREIRA BARRETO", "PIACATU", "RUBIÁCEA", "SANTO ANTÔNIO DO ARACANGUÁ", "SANTÓPOLIS DO AGUAPEÍ", "SUD MENNUCCI", "SUZANÁPOLIS", "TURIÚBA", "VALPARAÍSO"],
   'drs3_araraquara': ["MÉRICO BRASILIENSE", "ARARAQUARA", "BOA ESPERANÇA DO SUL", "BORBOREMA", "CÂNDIDO RODRIGUES", "DESCALVADO", "DOBRADA", "DOURADO", "GAVIÃO PEIXOTO", "IBATÉ", "IBITINGA", "ITÁPOLIS", "MATÃO", "MOTUCA", "NOVA EUROPA", "PORTO FERREIRA", "RIBEIRÃO BONITO", "RINCÃO", "SANTA ERNESTINA", "SANTA LÚCIA", "SÃO CARLOS", "TABATINGA", "TAQUARITINGA", "TRABIJU"],
   'drs4_baixa_santista': ["BERTIOGA", "CUBATÃO", "GUARUJÁ", "ITANHAÉM", "MONGAGUÁ", "PERUÍBE", "PRAIA GRANDE", "SANTOS", "SÃO VICENTE"],
   'drs5_barretos': ["ALTAIR", "BARRETOS", "BEBEDOURO", "CAJOBI", "COLINA", "COLÔMBIA", "GUAÍRA", "GUARACI", "JABORANDI", "MONTE AZUL", "PAULISTA", "OLÍMPIA", "SEVERÍNIA", "TAIAÇU", "TAIÚVA", "TAQUARAL", "TERRA ROXA", "VIRADOURO", "VISTA ALEGRE DO ALTO"],
   'drs6_bauru': ["ÁGUAS DE SANTA BÁRBARA", "AGUDOS", "ANHEMBI", "ARANDU", "AREALVA", "AREIÓPOLIS", "AVAÍ", "AVARÉ", "BALBINOS", "BARÃO DE ANTONINA", "BARIRI", "BARRA BONITA", "BAURU", "BOCAINA", "BOFETE", "BORACÉIA", "BOREBI", "BOTUCATU", "BROTAS", "CABRÁLIA PAULISTA", "CAFELÂNDIA", "CERQUEIRA CÉSAR", "CONCHAS", "CORONEL MACEDO", "DOIS CÓRREGOS",
                  "DUARTINA", "FARTURA", "GETULINA", "GUAIÇARA", "IACANGA", "IARAS", "IGARAÇU DO TIETÊ", "ITAÍ", "ITAJU", "ITAPORANGA", "ITAPUÍ", "ITATINGA", "JAÚ", "LARANJAL PAULISTA", "LENÇÓIS PAULISTA", "LINS", "LUCIANÓPOLIS",
                  "MACATUBA", "MANDURI", "MINEIROS DO TIETÊ", "PARANAPANEMA", "PARDINHO", "PAULISTÂNIA", "PEDERNEIRAS", "PEREIRAS", "PIRAJU", "PIRAJUÍ", "PIRATININGA", "PONGAÍ", "PORANGABA", "PRATÂNIA", "PRESIDENTE ALVES", "PROMISSÃO", "REGINÓPOLIS", "SABINO", "SÃO MANUEL", "SARUTAIÁ", "TAGUAÍ", "TAQUARITUBA", "TEJUPÁ", "TORRE DE PEDRA", "TORRINHA", "URU"],
   'drs7_campinas': ["ÁGUAS DE LINDÓIA", "AMERICANA", "AMPARO", "ARTUR NOGUEIRA", "ATIBAIA", "BOM JESUS DOS PERDÕES", "BRAGANÇA PAULISTA", "CABREÚVA", "CAMPINAS", "CAMPO LIMPO PAULISTA", "COSMÓPOLIS", "HOLAMBRA", "HORTOLÂNDIA", "INDAIATUBA",
                     "ITATIBA", "ITUPEVA", "JAGUARIÚNA", "JARINU", "JOANÓPOLIS", "JUNDIAÍ", "LINDÓIA", "LOUVEIRA", "MONTE ALEGRE DO SUL", "MONTE MOR", "MORUNGABA", "NAZARÉ PAULISTA", "NOVA ODESSA", "PAULÍNIA", "PEDRA BELA", "PEDREIRA", "PINHALZINHO", "PIRACAIA", "SANTA BÁRBARA D'OESTE", "SANTO ANTÔNIO DA POSSE", "SERRA NEGRA", "SOCORRO", "SUMARÉ", "TUIUTI", "VALINHOS", "VARGEM", "VÁRZEA PAULISTA", "VINHEDO"],
   'drs8_franca': ["ARAMINA", "BURITIZAL", "CRISTAIS PAULISTA", "FRANCA", "GUARÁ", "IGARAPAVA", "IPUÃ", "ITIRAPUÃ", "ITUVERAVA", "JERIQUARA", "MIGUELÓPOLIS", "MORRO AGUDO", "NUPORANGA", "ORLÂNDIA", "PATROCÍNIO PAULISTA", "PEDREGULHO", "RESTINGA", "RIBEIRÃO CORRENTE", "RIFAINA", "SALES OLIVEIRA", "SÃO JOAQUIM DA BARRA", "SÃO JOSÉ DA BELA VISTA"],
   'drs9_marilia': ["ADAMANTINA", "ÁLVARO DE CARVALHO", "ALVINLÂNDIA", "ARCO ÍRIS", "ASSIS", "BASTOS", "BERNARDINO DE CAMPOS", "BORÁ", "CAMPOS NOVOS PAULISTA", "CÂNDIDO MOTA", "CANITAR", "CHAVANTES", "CRUZÁLIA", "ECHAPORÃ", "ESPÍRITO SANTO DO TURVO", "FERNÃO", "FLÓRIDA PAULISTA", "FLORÍNIA", "GÁLIA", "GARÇA", "GUAIMBÊ", "GUARANTÃ", "HERCULÂNDIA",
                    "IACRI", "IBIRAREMA", "INÚBIA PAULISTA", "IPAUSSU", "JÚLIO MESQUITA", "LUCÉLIA", "LUPÉRCIO", "LUTÉCIA", "MARACAÍ", "MARIÁPOLIS", "MARÍLIA", "OCAUÇU", "ÓLEO", "ORIENTE", "OSCAR BRESSANE", "OSVALDO CRUZ", "OURINHOS", "PACAEMBU", "PALMITAL", "PARAGUAÇU PAULISTA", "PARAPUÃ", "PEDRINHAS PAULISTA", "PLATINA", "POMPÉIA", "PRACINHA",
                    "QUEIROZ", "QUINTANA", "RIBEIRÃO DO SUL", "RINÓPOLIS", "SAGRES", "SALMOURÃO", "SALTO GRANDE", "SANTA CRUZ DO RIO PARDO", "SÃO PEDRO DO TURVO", "TARUMÃ", "TIMBURI", "TUPÃ", "UBIRAJARA", "VERA CRUZ"],
    'drs10_piracicaba': ["ÁGUAS DE SÃO PEDRO", "ANALÂNDIA", "ARARAS", "CAPIVARI", "CHARQUEADA", "CONCHAL", "CORDEIRÓPOLIS", "CORUMBATAÍ", "ELIAS FAUSTO", "ENGENHEIRO COELHO", "IPEÚNA", "IRACEMÁPOLIS", "ITIRAPINA", "LEME", "LIMEIRA", "MOMBUCA", "PIRACICABA", "PIRASSUNUNGA", "RAFARD", "RIO CLARO", "RIO DAS PEDRAS", "SALTINHO", "SANTA CRUZ DA CONCEIÇÃO", "SANTA GERTRUDES", "SANTA MARIA DA SERRA", "SÃO PEDRO"],
    'drs11_presidente_prudente': ["ALFREDO MARCONDES", "ÁLVARES MACHADO", "ANHUMAS", "CAIABU", "CAIUÁ", "DRACENA", "EMILIANÓPOLIS", "ESTRELA DO NORTE", "EUCLIDES DA CUNHA PAULISTA", "FLORA RICA", "IEPÊ", "INDIANA", "IRAPURU", "JOÃO RAMALHO", "JUNQUEIRÓPOLIS", "MARABÁ PAULISTA", "MARTINÓPOLIS", "MIRANTE DO PARANAPANEMA", "MONTE CASTELO", "NANTES", "NARANDIBA", "NOVA GUATAPORANGA", "OURO VERDE",
                                  "PANORAMA", "PAULICÉIA", "PIQUEROBI", "PIRAPOZINHO", "PRESIDENTE BERNARDES", "PRESIDENTE EPITÁCIO", "PRESIDENTE PRUDENTE", "PRESIDENTE VENCESLAU", "QUATÁ", "RANCHARIA", "REGENTE FEIJÓ", "RIBEIRÃO DOS ÍNDIOS", "ROSANA", "SANDOVALINA", "SANTA MERCEDES", "SANTO ANASTÁCIO", "SANTO EXPEDITO", "SÃO JOÃO DO PAU D'ALHO", "TACIBA", "TARABAI", "TEODORO SAMPAIO", "TUPI PAULISTA"],
    'drs12_registro': ["BARRA DO TURVO", "CAJATI", "CANANÉIA", "ELDORADO", "IGUAPE", "ILHA COMPRIDA", "IPORANGA", "ITARIRI", "JACUPIRANGA", "JUQUIÁ", "MIRACATU", "PARIQUERA-AÇU", "PEDRO DE TOLEDO", "REGISTRO", "SETE BARRAS"],
    'drs13_ribeirao_preto': ["ALTINÓPOLIS", "BARRINHA", "BATATAIS", "BRODOWSKI", "CAJURU", "CÁSSIA DOS COQUEIROS", "CRAVINHOS", "DUMONT", "GUARIBA", "GUATAPARÁ", "JABOTICABAL", "JARDINÓPOLIS", "LUÍS ANTÔNIO", "MONTE ALTO", "PITANGUEIRAS", "PONTAL", "PRADÓPOLIS", "RIBEIRÃO PRETO", "SANTA CRUZ DA ESPERANÇA", "SANTA RITA DO PASSA QUATRO", "SANTA ROSA DE VITERBO", "SANTO ANTÔNIO DA ALEGRIA", "SÃO SIMÃO", "SERRA AZUL", "SERRANA", "SERTÃOZINHO"],
    'drs14_sao_joao_da_boa_vista': ["AGUAÍ", "ÁGUAS DA PRATA", "CACONDE", "CASA BRANCA", "DIVINOLÂNDIA", "ESPÍRITO SANTO DO PINHAL", "ESTIVA GERBI", "ITAPIRA", "ITOBI", "MOCOCA", "MOGI GUAÇU", "MOGI MIRIM", "SANTA CRUZ DAS PALMEIRAS", "SANTO ANTÔNIO DO JARDIM", "SÃO JOÃO DA BOA VISTA", "SÃO JOSÉ DO RIO PARDO", "SÃO SEBASTIÃO DA GRAMA", "TAMBAÚ", "TAPIRATIBA", "VARGEM GRANDE DO SUL"],
    'drs15_sao_jose_do_rio_preto': ["ADOLFO", "ÁLVARES FLORENCE", "AMÉRICO DE CAMPOS", "APARECIDA D'OESTE", "ARIRANHA", "ASPÁSIA", "BADY BASSIT", "BÁLSAMO", "CARDOSO", "CATANDUVA", "CATIGUÁ", "CEDRAL", "COSMORAMA", "DIRCE REIS", "DOLCINÓPOLIS", "ELISIÁRIO", "EMBAÚBA", "ESTRELA D'OESTE", "FERNANDÓPOLIS", "FERNANDO PRESTES", "FLOREAL", "GASTÃO VIDIGAL", "GENERAL SALGADO", "GUAPIAÇU", "GUARANI D'OESTE",
                                    "IBIRÁ", "ICÉM", "INDIAPORÃ", "IPIGUÁ", "IRAPUÃ", "ITAJOBI", "JACI", "JALES", "JOSÉ BONIFÁCIO", "MACAUBAL", "MACEDÔNIA", "MAGDA", "MARAPOAMA", "MARINÓPOLIS", "MENDONÇA", "MERIDIANO", "MESÓPOLIS", "MIRA ESTRELA", "MIRASSOL", "MIRASSOLÂNDIA", "MONÇÕES", "MONTE APRAZÍVEL", "NEVES PAULISTA", "NHANDEARA", "NIPOÃ", "NOVA ALIANÇA", "NOVA CANAÃ PAULISTA", "NOVA GRANADA", "NOVAIS",
                                    "NOVO HORIZONTE", "ONDA VERDE", "ORINDIÚVA", "OUROESTE", "PALESTINA", "PALMARES PAULISTA", "PALMEIRA D'OESTE", "PARAÍSO", "PARANAPUÃ", "PARISI", "PAULO DE FARIA", "PEDRANÓPOLIS", "PINDORAMA", "PIRANGI", "PLANALTO", "POLONI", "PONTALINDA", "PONTES GESTAL", "POPULINA", "POTIRENDABA", "RIOLÂNDIA", "RUBINÉIA", "SALES", "SANTA ADÉLIA", "SANTA ALBERTINA", "SANTA CLARA D'OESTE",
                                    "SANTA FÉ DO SUL", "SANTA RITA D'OESTE", "SANTA SALETE", "SANTANA DA PONTE PENSA", "SÃO FRANCISCO", "SÃO JOÃO DAS DUAS PONTES", "SÃO JOÃO DE IRACEMA", "SÃO JOSÉ DO RIO PRETO", "SEBASTIANÓPOLIS DO SUL", "TABAPUÃ", "TANABI", "TRÊS FRONTEIRAS", "TURMALINA", "UBARANA", "UCHOA", "UNIÃO PAULISTA", "URÂNIA", "URUPÊS", "VALENTIM GENTIL", "VITÓRIA BRASIL", "VOTUPORANGA", "ZACARIAS"],
    'drs16_sorocaba': ["ALAMBARI", "ALUMÍNIO", "ANGATUBA", "APIAÍ", "ARAÇARIGUAMA", "ARAÇOIABA DA SERRA", "BARRA DO CHAPÉU", "BOITUVA", "BOM SUCESSO DE ITARARÉ", "BURI", "CAMPINA DO MONTE ALEGRE", "CAPÃO BONITO", "CAPELA DO ALTO", "CERQUILHO", "CESÁRIO LANGE", "GUAPIARA", "GUAREÍ",
                   "IBIÚNA", "IPERÓ", "ITABERÁ", "ITAÓCA", "ITAPETININGA", "ITAPEVA", "ITAPIRAPUÃ PAULISTA", "ITARARÉ", "ITU", "JUMIRIM", "MAIRINQUE", "NOVA CAMPINA", "PIEDADE", "PILAR DO SUL", "PORTO FELIZ", "QUADRA", "RIBEIRA", "RIBEIRÃO BRANCO", "RIBEIRÃO GRANDE", "RIVERSUL", "SALTO", "SALTO DE PIRAPORA", "SÃO MIGUEL ARCANJO", "SÃO ROQUE", "SARAPUÍ", "SOROCABA", "TAPIRAÍ", "TAQUARIVAÍ", "TATUÍ", "TIETÊ", "VOTORANTIM"],
    'drs17_taubate': ["APARECIDA", "ARAPEÍ", "AREIAS", "BANANAL", "CAÇAPAVA", "CACHOEIRA PAULISTA", "CAMPOS DO JORDÃO", "CANAS", "CARAGUATATUBA", "CRUZEIRO", "CUNHA", "GUARATINGUETÁ", "IGARATÁ", "ILHA BELA", "JACAREÍ", "JAMBEIRO", "LAGOINHA", "LAVRINHAS", "LORENA", "MONTEIRO LOBATO", "NATIVIDADE DA SERRA", "PARAIBUNA", "PINDAMONHANGABA", "PIQUETE", "POTIM", "QUELUZ", "REDENÇÃO DA SERRA", "ROSEIRA", "SANTA BRANCA", "SANTO ANTÔNIO DO PINHAL",
                  "SÃO BENTO DO SAPUCAÍ", "SÃO JOSÉ DO BARREIRO", "SÃO JOSÉ DOS CAMPOS", "SÃO LUIZ DO PARAITINGA", "SÃO SEBASTIÃO", "SILVEIRAS", "TAUBATÉ", "TREMEMBÉ", "UBATUBA"]
}


# Adicionar coluna DS ao DataFrame com valores nulos inicialmente
municipios_df['DS'] = pd.NA

# Atualizar o DataFrame com a nova coluna DS
for ds, municipios in drs_data.items():
    municipios_df.loc[municipios_df['Município'].str.upper().isin(municipios), 'DS'] = ds

# Verificar se a coluna DS foi preenchida corretamente
print(municipios_df[['Município', 'DS']].head())

"""Mapa com DS - regional de saude"""

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_ds = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar os municípios por DS e definir cores para cada DS
ds_unique = municipios_df['DS'].unique()
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'brown', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']

ds_colors = {ds: colors[i % len(colors)] for i, ds in enumerate(ds_unique)}

# Criar FeatureGroups para cada DS
feature_groups = {ds: FeatureGroup(name=f"Divisão de Saúde: {ds}", show=False) for ds in ds_unique}

# Adicionar FeatureGroups ao mapa
for fg in feature_groups.values():
    fg.add_to(mapa_sp_ds)

# Adicionar marcadores e polígonos ao mapa
for ds, group in municipios_df.groupby('DS'):
    coords = group[['Latitude', 'Longitude']].values.tolist()
    print(f"Adicionando polígono para {ds} com coordenadas: {coords}")  # Depuração
    folium.Polygon(
        locations=coords,
        popup=f"Divisão de Saúde: {ds}",
        color=ds_colors[ds],
        fill=True,
        fill_color=ds_colors[ds],
        fill_opacity=0.4
    ).add_to(feature_groups[ds])

    for idx, row in group.iterrows():
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['Município']}: {row['DS']}",
            tooltip=f"População 2020: {row['População 2020']}",
            icon=folium.Icon(color='blue', icon='info-sign')
        ).add_to(feature_groups[ds])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_ds)


# Salvar e mostrar o mapa
mapa_sp_ds.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_ds.html')
print("Mapa salvo como 'interactive_map_ds.html'")

mapa_sp_ds

"""No contexto do código fornecido, os polígonos são formados a partir das coordenadas geográficas (latitude e longitude) dos municípios que pertencem a uma mesma Divisão Regional de Saúde (DS).

O objetivo é visualizar as áreas de cada DS no mapa.

### Formação do Polígono:

1. **Agrupamento por DS**:

   - Os municípios são agrupados com base na coluna `DS`, que indica a qual Divisão Regional de Saúde cada município pertence.

2. **Extração das Coordenadas**:

   - Para cada grupo (cada DS), as coordenadas dos municípios pertencentes a essa DS são extraídas.

3. **Criação do Polígono**:

   - Um polígono é criado usando as coordenadas dos municípios. As coordenadas são passadas como uma lista de listas para a função `folium.Polygon`.


### Passos Detalhados:

1. **Agrupamento dos Municípios**:

   - `municipios_df.groupby('DS')`: Esta linha agrupa os municípios com base na coluna `DS`.

2. **Extração das Coordenadas**:

   - `coords = group[['Latitude', 'Longitude']].values.tolist()`: Esta linha extrai as coordenadas (latitude e longitude) dos municípios no grupo atual e as converte em uma lista de listas. Cada sublista contém as coordenadas de um município.

3. **Criação do Polígono**:

   - `folium.Polygon(locations=coords, ...)`: A função `folium.Polygon` cria um polígono no mapa usando as coordenadas fornecidas. Os parâmetros adicionais configuram a aparência e o comportamento do polígono:
     - `locations=coords`: Especifica as coordenadas dos vértices do polígono.
     - `popup=f"Divisão de Saúde: {ds}"`: Adiciona um popup que aparece ao clicar no polígono, mostrando a Divisão de Saúde.
     - `color=ds_colors[ds]`: Define a cor da borda do polígono.
     - `fill=True`: Habilita o preenchimento do polígono.
     - `fill_color=ds_colors[ds]`: Define a cor de preenchimento do polígono.
     - `fill_opacity=0.4`: Define a opacidade do preenchimento.

### Ligações Realizadas:

Os vértices do polígono são ligados sequencialmente, ou seja, a primeira coordenada é ligada à segunda, a segunda à terceira, e assim por diante, até a última coordenada ser ligada de volta à primeira para fechar o polígono. Isto forma um contorno que representa a área coberta pelos municípios da Divisão Regional de Saúde.

### Visualização do Polígono:

Cada polígono representa uma Divisão Regional de Saúde, e a área dentro do polígono é preenchida com a cor designada para essa DS. Isso ajuda a visualizar facilmente quais municípios pertencem a cada Divisão Regional de Saúde e a entender a distribuição geográfica dos serviços de saúde no estado.

### Exemplo de Visualização:

- **Divisão Regional de Saúde (DS)**: Cada DS é representada por um polígono colorido no mapa.
- **Municípios**: Dentro de cada polígono, cada município pode ser marcado com um marcador específico, e ao passar o mouse sobre um marcador ou clicar nele, informações adicionais sobre o município (como população) podem ser exibidas.
"""

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_ds_pop = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar os municípios por DS e definir cores para cada DS
ds_unique = municipios_df['DS'].unique()
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'brown', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']

ds_colors = {ds: colors[i % len(colors)] for i, ds in enumerate(ds_unique)}

# Criar FeatureGroups para cada DS
feature_groups = {ds: FeatureGroup(name=f"Divisão de Saúde: {ds}", show=False) for ds in ds_unique}

# Adicionar FeatureGroups ao mapa
for fg in feature_groups.values():
    fg.add_to(mapa_sp_ds_pop)

# Ordenar os municípios dentro de cada DS por população
for ds, group in municipios_df.groupby('DS'):
    # Ordenar pelos valores de população, por exemplo, em ordem decrescente
    group_sorted = group.sort_values(by='População 2020', ascending=False)
    coords = group_sorted[['Latitude', 'Longitude']].values.tolist()

    # Adicionar polígono ao mapa
    folium.Polygon(
        locations=coords,
        popup=f"Divisão de Saúde: {ds}",
        color=ds_colors[ds],
        fill=True,
        fill_color=ds_colors[ds],
        fill_opacity=0.4
    ).add_to(feature_groups[ds])

    # Adicionar marcadores
    for idx, row in group_sorted.iterrows():
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['Município']}: {row['DS']}",
            tooltip=f"População 2020: {row['População 2020']}",
            icon=folium.Icon(color='blue', icon='info-sign')
        ).add_to(feature_groups[ds])


# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_ds_pop)


# Salvar e mostrar o mapa
mapa_sp_ds_pop.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_ds_pop.html')
print("Mapa salvo como 'interactive_map_ds.html'")

"""os municípios dentro de cada DS são ordenados pela população em ordem decrescente antes de formar o polígono.

Isso pode resultar em uma forma diferente para os polígonos, dependendo da distribuição das populações.
"""

mapa_sp_ds_pop

"""ds com o filtro assunto"""

import pandas as pd
import folium
from folium import LayerControl, FeatureGroup
from folium.plugins import MarkerCluster

# Carregar dados do arquivo CSV
municipios_df = municipio

# Definir os municípios por DRS diretamente no código

drs_data = {
   'drs1': ["ARUJÁ", "BARUERI", "BIRITIBA-MIRIM", "CAIEIRAS", "CAJAMAR", "CARAPICUÍBA", "COTIA", "DIADEMA", "EMBU", "EMBU-GUAÇU", "FERRAZ DE VASCONCELOS", "FRANCISCO MORATO", "FRANCO DA ROCHA", "GUARAREMA", "GUARULHOS", "ITAPECERICA DA SERRA", "ITAPEVI", "ITAQUAQUECETUBA", "JANDIRA", "JUQUITIBA", "MAIRIPORÃ", "MAUÁ", "MOGI DAS CRUZES", "OSASCO", "PIRAPORA DO BOM JESUS", "POÁ", "RIBEIRÃO PIRES", "RIO GRANDE DA SERRA", "SALESÓPOLIS", "SANTA ISABEL", "SANTANA DE PARNAÍBA", "SANTO ANDRÉ", "SÃO BERNARDO DO CAMPO", "SÃO CAETANO DO SUL", "SÃO LOURENÇO DA SERRA", "SÃO PAULO", "SUZANO", "TABOÃO DA SERRA", "VARGEM GRANDE PAULISTA"],
   'drs2_araçatuba': ["ALTO ALEGRE", "ANDRADINA", "ARAÇATUBA", "AURIFLAMA", "AVANHANDAVA", "BARBOSA", "BENTO DE ABREU", "BILAC", "BIRIGUI", "BRAÚNA", "BREJO ALEGRE", "BURITAMA", "CASTILHO", "CLEMENTINA", "COROADOS", "GABRIEL MONTEIRO", "GLICÉRIO", "GUARAÇAÍ", "GUARARAPES", "GUZOLÂNDIA", "ILHA SOLTEIRA", "ITAPURA", "LAVÍNIA", "LOURDES", "LUIZIÂNIA", "MIRANDÓPOLIS", "MURUTINGA DO SUL", "NOVA CASTILHO", "NOVA INDEPENDÊNCIA", "NOVA LUZITÂNIA", "PENÁPOLIS", "PEREIRA BARRETO", "PIACATU", "RUBIÁCEA", "SANTO ANTÔNIO DO ARACANGUÁ", "SANTÓPOLIS DO AGUAPEÍ", "SUD MENNUCCI", "SUZANÁPOLIS", "TURIÚBA", "VALPARAÍSO"],
   'drs3_araraquara': ["MÉRICO BRASILIENSE", "ARARAQUARA", "BOA ESPERANÇA DO SUL", "BORBOREMA", "CÂNDIDO RODRIGUES", "DESCALVADO", "DOBRADA", "DOURADO", "GAVIÃO PEIXOTO", "IBATÉ", "IBITINGA", "ITÁPOLIS", "MATÃO", "MOTUCA", "NOVA EUROPA", "PORTO FERREIRA", "RIBEIRÃO BONITO", "RINCÃO", "SANTA ERNESTINA", "SANTA LÚCIA", "SÃO CARLOS", "TABATINGA", "TAQUARITINGA", "TRABIJU"],
   'drs4_baixa_santista': ["BERTIOGA", "CUBATÃO", "GUARUJÁ", "ITANHAÉM", "MONGAGUÁ", "PERUÍBE", "PRAIA GRANDE", "SANTOS", "SÃO VICENTE"],
   'drs5_barretos': ["ALTAIR", "BARRETOS", "BEBEDOURO", "CAJOBI", "COLINA", "COLÔMBIA", "GUAÍRA", "GUARACI", "JABORANDI", "MONTE AZUL", "PAULISTA", "OLÍMPIA", "SEVERÍNIA", "TAIAÇU", "TAIÚVA", "TAQUARAL", "TERRA ROXA", "VIRADOURO", "VISTA ALEGRE DO ALTO"],
   'drs6_bauru': ["ÁGUAS DE SANTA BÁRBARA", "AGUDOS", "ANHEMBI", "ARANDU", "AREALVA", "AREIÓPOLIS", "AVAÍ", "AVARÉ", "BALBINOS", "BARÃO DE ANTONINA", "BARIRI", "BARRA BONITA", "BAURU", "BOCAINA", "BOFETE", "BORACÉIA", "BOREBI", "BOTUCATU", "BROTAS", "CABRÁLIA PAULISTA", "CAFELÂNDIA", "CERQUEIRA CÉSAR", "CONCHAS", "CORONEL MACEDO", "DOIS CÓRREGOS",
                  "DUARTINA", "FARTURA", "GETULINA", "GUAIÇARA", "IACANGA", "IARAS", "IGARAÇU DO TIETÊ", "ITAÍ", "ITAJU", "ITAPORANGA", "ITAPUÍ", "ITATINGA", "JAÚ", "LARANJAL PAULISTA", "LENÇÓIS PAULISTA", "LINS", "LUCIANÓPOLIS",
                  "MACATUBA", "MANDURI", "MINEIROS DO TIETÊ", "PARANAPANEMA", "PARDINHO", "PAULISTÂNIA", "PEDERNEIRAS", "PEREIRAS", "PIRAJU", "PIRAJUÍ", "PIRATININGA", "PONGAÍ", "PORANGABA", "PRATÂNIA", "PRESIDENTE ALVES", "PROMISSÃO", "REGINÓPOLIS", "SABINO", "SÃO MANUEL", "SARUTAIÁ", "TAGUAÍ", "TAQUARITUBA", "TEJUPÁ", "TORRE DE PEDRA", "TORRINHA", "URU"],
   'drs7_campinas': ["ÁGUAS DE LINDÓIA", "AMERICANA", "AMPARO", "ARTUR NOGUEIRA", "ATIBAIA", "BOM JESUS DOS PERDÕES", "BRAGANÇA PAULISTA", "CABREÚVA", "CAMPINAS", "CAMPO LIMPO PAULISTA", "COSMÓPOLIS", "HOLAMBRA", "HORTOLÂNDIA", "INDAIATUBA",
                     "ITATIBA", "ITUPEVA", "JAGUARIÚNA", "JARINU", "JOANÓPOLIS", "JUNDIAÍ", "LINDÓIA", "LOUVEIRA", "MONTE ALEGRE DO SUL", "MONTE MOR", "MORUNGABA", "NAZARÉ PAULISTA", "NOVA ODESSA", "PAULÍNIA", "PEDRA BELA", "PEDREIRA", "PINHALZINHO", "PIRACAIA", "SANTA BÁRBARA D'OESTE", "SANTO ANTÔNIO DA POSSE", "SERRA NEGRA", "SOCORRO", "SUMARÉ", "TUIUTI", "VALINHOS", "VARGEM", "VÁRZEA PAULISTA", "VINHEDO"],
   'drs8_franca': ["ARAMINA", "BURITIZAL", "CRISTAIS PAULISTA", "FRANCA", "GUARÁ", "IGARAPAVA", "IPUÃ", "ITIRAPUÃ", "ITUVERAVA", "JERIQUARA", "MIGUELÓPOLIS", "MORRO AGUDO", "NUPORANGA", "ORLÂNDIA", "PATROCÍNIO PAULISTA", "PEDREGULHO", "RESTINGA", "RIBEIRÃO CORRENTE", "RIFAINA", "SALES OLIVEIRA", "SÃO JOAQUIM DA BARRA", "SÃO JOSÉ DA BELA VISTA"],
   'drs9_marilia': ["ADAMANTINA", "ÁLVARO DE CARVALHO", "ALVINLÂNDIA", "ARCO ÍRIS", "ASSIS", "BASTOS", "BERNARDINO DE CAMPOS", "BORÁ", "CAMPOS NOVOS PAULISTA", "CÂNDIDO MOTA", "CANITAR", "CHAVANTES", "CRUZÁLIA", "ECHAPORÃ", "ESPÍRITO SANTO DO TURVO", "FERNÃO", "FLÓRIDA PAULISTA", "FLORÍNIA", "GÁLIA", "GARÇA", "GUAIMBÊ", "GUARANTÃ", "HERCULÂNDIA",
                    "IACRI", "IBIRAREMA", "INÚBIA PAULISTA", "IPAUSSU", "JÚLIO MESQUITA", "LUCÉLIA", "LUPÉRCIO", "LUTÉCIA", "MARACAÍ", "MARIÁPOLIS", "MARÍLIA", "OCAUÇU", "ÓLEO", "ORIENTE", "OSCAR BRESSANE", "OSVALDO CRUZ", "OURINHOS", "PACAEMBU", "PALMITAL", "PARAGUAÇU PAULISTA", "PARAPUÃ", "PEDRINHAS PAULISTA", "PLATINA", "POMPÉIA", "PRACINHA",
                    "QUEIROZ", "QUINTANA", "RIBEIRÃO DO SUL", "RINÓPOLIS", "SAGRES", "SALMOURÃO", "SALTO GRANDE", "SANTA CRUZ DO RIO PARDO", "SÃO PEDRO DO TURVO", "TARUMÃ", "TIMBURI", "TUPÃ", "UBIRAJARA", "VERA CRUZ"],
    'drs10_piracicaba': ["ÁGUAS DE SÃO PEDRO", "ANALÂNDIA", "ARARAS", "CAPIVARI", "CHARQUEADA", "CONCHAL", "CORDEIRÓPOLIS", "CORUMBATAÍ", "ELIAS FAUSTO", "ENGENHEIRO COELHO", "IPEÚNA", "IRACEMÁPOLIS", "ITIRAPINA", "LEME", "LIMEIRA", "MOMBUCA", "PIRACICABA", "PIRASSUNUNGA", "RAFARD", "RIO CLARO", "RIO DAS PEDRAS", "SALTINHO", "SANTA CRUZ DA CONCEIÇÃO", "SANTA GERTRUDES", "SANTA MARIA DA SERRA", "SÃO PEDRO"],
    'drs11_presidente_prudente': ["ALFREDO MARCONDES", "ÁLVARES MACHADO", "ANHUMAS", "CAIABU", "CAIUÁ", "DRACENA", "EMILIANÓPOLIS", "ESTRELA DO NORTE", "EUCLIDES DA CUNHA PAULISTA", "FLORA RICA", "IEPÊ", "INDIANA", "IRAPURU", "JOÃO RAMALHO", "JUNQUEIRÓPOLIS", "MARABÁ PAULISTA", "MARTINÓPOLIS", "MIRANTE DO PARANAPANEMA", "MONTE CASTELO", "NANTES", "NARANDIBA", "NOVA GUATAPORANGA", "OURO VERDE",
                                  "PANORAMA", "PAULICÉIA", "PIQUEROBI", "PIRAPOZINHO", "PRESIDENTE BERNARDES", "PRESIDENTE EPITÁCIO", "PRESIDENTE PRUDENTE", "PRESIDENTE VENCESLAU", "QUATÁ", "RANCHARIA", "REGENTE FEIJÓ", "RIBEIRÃO DOS ÍNDIOS", "ROSANA", "SANDOVALINA", "SANTA MERCEDES", "SANTO ANASTÁCIO", "SANTO EXPEDITO", "SÃO JOÃO DO PAU D'ALHO", "TACIBA", "TARABAI", "TEODORO SAMPAIO", "TUPI PAULISTA"],
    'drs12_registro': ["BARRA DO TURVO", "CAJATI", "CANANÉIA", "ELDORADO", "IGUAPE", "ILHA COMPRIDA", "IPORANGA", "ITARIRI", "JACUPIRANGA", "JUQUIÁ", "MIRACATU", "PARIQUERA-AÇU", "PEDRO DE TOLEDO", "REGISTRO", "SETE BARRAS"],
    'drs13_ribeirao_preto': ["ALTINÓPOLIS", "BARRINHA", "BATATAIS", "BRODOWSKI", "CAJURU", "CÁSSIA DOS COQUEIROS", "CRAVINHOS", "DUMONT", "GUARIBA", "GUATAPARÁ", "JABOTICABAL", "JARDINÓPOLIS", "LUÍS ANTÔNIO", "MONTE ALTO", "PITANGUEIRAS", "PONTAL", "PRADÓPOLIS", "RIBEIRÃO PRETO", "SANTA CRUZ DA ESPERANÇA", "SANTA RITA DO PASSA QUATRO", "SANTA ROSA DE VITERBO", "SANTO ANTÔNIO DA ALEGRIA", "SÃO SIMÃO", "SERRA AZUL", "SERRANA", "SERTÃOZINHO"],
    'drs14_sao_joao_da_boa_vista': ["AGUAÍ", "ÁGUAS DA PRATA", "CACONDE", "CASA BRANCA", "DIVINOLÂNDIA", "ESPÍRITO SANTO DO PINHAL", "ESTIVA GERBI", "ITAPIRA", "ITOBI", "MOCOCA", "MOGI GUAÇU", "MOGI MIRIM", "SANTA CRUZ DAS PALMEIRAS", "SANTO ANTÔNIO DO JARDIM", "SÃO JOÃO DA BOA VISTA", "SÃO JOSÉ DO RIO PARDO", "SÃO SEBASTIÃO DA GRAMA", "TAMBAÚ", "TAPIRATIBA", "VARGEM GRANDE DO SUL"],
    'drs15_sao_jose_do_rio_preto': ["ADOLFO", "ÁLVARES FLORENCE", "AMÉRICO DE CAMPOS", "APARECIDA D'OESTE", "ARIRANHA", "ASPÁSIA", "BADY BASSIT", "BÁLSAMO", "CARDOSO", "CATANDUVA", "CATIGUÁ", "CEDRAL", "COSMORAMA", "DIRCE REIS", "DOLCINÓPOLIS", "ELISIÁRIO", "EMBAÚBA", "ESTRELA D'OESTE", "FERNANDÓPOLIS", "FERNANDO PRESTES", "FLOREAL", "GASTÃO VIDIGAL", "GENERAL SALGADO", "GUAPIAÇU", "GUARANI D'OESTE",
                                    "IBIRÁ", "ICÉM", "INDIAPORÃ", "IPIGUÁ", "IRAPUÃ", "ITAJOBI", "JACI", "JALES", "JOSÉ BONIFÁCIO", "MACAUBAL", "MACEDÔNIA", "MAGDA", "MARAPOAMA", "MARINÓPOLIS", "MENDONÇA", "MERIDIANO", "MESÓPOLIS", "MIRA ESTRELA", "MIRASSOL", "MIRASSOLÂNDIA", "MONÇÕES", "MONTE APRAZÍVEL", "NEVES PAULISTA", "NHANDEARA", "NIPOÃ", "NOVA ALIANÇA", "NOVA CANAÃ PAULISTA", "NOVA GRANADA", "NOVAIS",
                                    "NOVO HORIZONTE", "ONDA VERDE", "ORINDIÚVA", "OUROESTE", "PALESTINA", "PALMARES PAULISTA", "PALMEIRA D'OESTE", "PARAÍSO", "PARANAPUÃ", "PARISI", "PAULO DE FARIA", "PEDRANÓPOLIS", "PINDORAMA", "PIRANGI", "PLANALTO", "POLONI", "PONTALINDA", "PONTES GESTAL", "POPULINA", "POTIRENDABA", "RIOLÂNDIA", "RUBINÉIA", "SALES", "SANTA ADÉLIA", "SANTA ALBERTINA", "SANTA CLARA D'OESTE",
                                    "SANTA FÉ DO SUL", "SANTA RITA D'OESTE", "SANTA SALETE", "SANTANA DA PONTE PENSA", "SÃO FRANCISCO", "SÃO JOÃO DAS DUAS PONTES", "SÃO JOÃO DE IRACEMA", "SÃO JOSÉ DO RIO PRETO", "SEBASTIANÓPOLIS DO SUL", "TABAPUÃ", "TANABI", "TRÊS FRONTEIRAS", "TURMALINA", "UBARANA", "UCHOA", "UNIÃO PAULISTA", "URÂNIA", "URUPÊS", "VALENTIM GENTIL", "VITÓRIA BRASIL", "VOTUPORANGA", "ZACARIAS"],
    'drs16_sorocaba': ["ALAMBARI", "ALUMÍNIO", "ANGATUBA", "APIAÍ", "ARAÇARIGUAMA", "ARAÇOIABA DA SERRA", "BARRA DO CHAPÉU", "BOITUVA", "BOM SUCESSO DE ITARARÉ", "BURI", "CAMPINA DO MONTE ALEGRE", "CAPÃO BONITO", "CAPELA DO ALTO", "CERQUILHO", "CESÁRIO LANGE", "GUAPIARA", "GUAREÍ",
                   "IBIÚNA", "IPERÓ", "ITABERÁ", "ITAÓCA", "ITAPETININGA", "ITAPEVA", "ITAPIRAPUÃ PAULISTA", "ITARARÉ", "ITU", "JUMIRIM", "MAIRINQUE", "NOVA CAMPINA", "PIEDADE", "PILAR DO SUL", "PORTO FELIZ", "QUADRA", "RIBEIRA", "RIBEIRÃO BRANCO", "RIBEIRÃO GRANDE", "RIVERSUL", "SALTO", "SALTO DE PIRAPORA", "SÃO MIGUEL ARCANJO", "SÃO ROQUE", "SARAPUÍ", "SOROCABA", "TAPIRAÍ", "TAQUARIVAÍ", "TATUÍ", "TIETÊ", "VOTORANTIM"],
    'drs17_taubate': ["APARECIDA", "ARAPEÍ", "AREIAS", "BANANAL", "CAÇAPAVA", "CACHOEIRA PAULISTA", "CAMPOS DO JORDÃO", "CANAS", "CARAGUATATUBA", "CRUZEIRO", "CUNHA", "GUARATINGUETÁ", "IGARATÁ", "ILHA BELA", "JACAREÍ", "JAMBEIRO", "LAGOINHA", "LAVRINHAS", "LORENA", "MONTEIRO LOBATO", "NATIVIDADE DA SERRA", "PARAIBUNA", "PINDAMONHANGABA", "PIQUETE", "POTIM", "QUELUZ", "REDENÇÃO DA SERRA", "ROSEIRA", "SANTA BRANCA", "SANTO ANTÔNIO DO PINHAL",
                  "SÃO BENTO DO SAPUCAÍ", "SÃO JOSÉ DO BARREIRO", "SÃO JOSÉ DOS CAMPOS", "SÃO LUIZ DO PARAITINGA", "SÃO SEBASTIÃO", "SILVEIRAS", "TAUBATÉ", "TREMEMBÉ", "UBATUBA"]
}


# Adicionar coluna DS ao DataFrame com valores nulos inicialmente
municipios_df['DS'] = pd.NA

# Atualizar o DataFrame com a nova coluna DS
for ds, municipios in drs_data.items():
    municipios_df.loc[municipios_df['Município'].str.upper().isin(municipios), 'DS'] = ds

# Verificar se a coluna DS foi preenchida corretamente
print(municipios_df[['Município', 'DS']].head())

# Adicionar uma coluna 'Assunto' ao DataFrame de municípios para demonstração
municipios_df['Assunto'] = 'Assunto Exemplo'  # Exemplo, substituir com dados reais
unique_assuntos = municipios_df['Assunto'].unique()

municipio

import pandas as pd
import folium
from folium import LayerControl, FeatureGroup
import ast

# Carregar dados do arquivo CSV
municipios_df = municipio

# Definir os municípios por DRS diretamente no código

drs_data = {
   'drs1': ["ARUJÁ", "BARUERI", "BIRITIBA-MIRIM", "CAIEIRAS", "CAJAMAR", "CARAPICUÍBA", "COTIA", "DIADEMA", "EMBU", "EMBU-GUAÇU", "FERRAZ DE VASCONCELOS", "FRANCISCO MORATO", "FRANCO DA ROCHA", "GUARAREMA", "GUARULHOS", "ITAPECERICA DA SERRA", "ITAPEVI", "ITAQUAQUECETUBA", "JANDIRA", "JUQUITIBA", "MAIRIPORÃ", "MAUÁ", "MOGI DAS CRUZES", "OSASCO", "PIRAPORA DO BOM JESUS", "POÁ", "RIBEIRÃO PIRES", "RIO GRANDE DA SERRA", "SALESÓPOLIS", "SANTA ISABEL", "SANTANA DE PARNAÍBA", "SANTO ANDRÉ", "SÃO BERNARDO DO CAMPO", "SÃO CAETANO DO SUL", "SÃO LOURENÇO DA SERRA", "SÃO PAULO", "SUZANO", "TABOÃO DA SERRA", "VARGEM GRANDE PAULISTA"],
   'drs2_araçatuba': ["ALTO ALEGRE", "ANDRADINA", "ARAÇATUBA", "AURIFLAMA", "AVANHANDAVA", "BARBOSA", "BENTO DE ABREU", "BILAC", "BIRIGUI", "BRAÚNA", "BREJO ALEGRE", "BURITAMA", "CASTILHO", "CLEMENTINA", "COROADOS", "GABRIEL MONTEIRO", "GLICÉRIO", "GUARAÇAÍ", "GUARARAPES", "GUZOLÂNDIA", "ILHA SOLTEIRA", "ITAPURA", "LAVÍNIA", "LOURDES", "LUIZIÂNIA", "MIRANDÓPOLIS", "MURUTINGA DO SUL", "NOVA CASTILHO", "NOVA INDEPENDÊNCIA", "NOVA LUZITÂNIA", "PENÁPOLIS", "PEREIRA BARRETO", "PIACATU", "RUBIÁCEA", "SANTO ANTÔNIO DO ARACANGUÁ", "SANTÓPOLIS DO AGUAPEÍ", "SUD MENNUCCI", "SUZANÁPOLIS", "TURIÚBA", "VALPARAÍSO"],
   'drs3_araraquara': ["MÉRICO BRASILIENSE", "ARARAQUARA", "BOA ESPERANÇA DO SUL", "BORBOREMA", "CÂNDIDO RODRIGUES", "DESCALVADO", "DOBRADA", "DOURADO", "GAVIÃO PEIXOTO", "IBATÉ", "IBITINGA", "ITÁPOLIS", "MATÃO", "MOTUCA", "NOVA EUROPA", "PORTO FERREIRA", "RIBEIRÃO BONITO", "RINCÃO", "SANTA ERNESTINA", "SANTA LÚCIA", "SÃO CARLOS", "TABATINGA", "TAQUARITINGA", "TRABIJU"],
   'drs4_baixa_santista': ["BERTIOGA", "CUBATÃO", "GUARUJÁ", "ITANHAÉM", "MONGAGUÁ", "PERUÍBE", "PRAIA GRANDE", "SANTOS", "SÃO VICENTE"],
   'drs5_barretos': ["ALTAIR", "BARRETOS", "BEBEDOURO", "CAJOBI", "COLINA", "COLÔMBIA", "GUAÍRA", "GUARACI", "JABORANDI", "MONTE AZUL", "PAULISTA", "OLÍMPIA", "SEVERÍNIA", "TAIAÇU", "TAIÚVA", "TAQUARAL", "TERRA ROXA", "VIRADOURO", "VISTA ALEGRE DO ALTO"],
   'drs6_bauru': ["ÁGUAS DE SANTA BÁRBARA", "AGUDOS", "ANHEMBI", "ARANDU", "AREALVA", "AREIÓPOLIS", "AVAÍ", "AVARÉ", "BALBINOS", "BARÃO DE ANTONINA", "BARIRI", "BARRA BONITA", "BAURU", "BOCAINA", "BOFETE", "BORACÉIA", "BOREBI", "BOTUCATU", "BROTAS", "CABRÁLIA PAULISTA", "CAFELÂNDIA", "CERQUEIRA CÉSAR", "CONCHAS", "CORONEL MACEDO", "DOIS CÓRREGOS",
                  "DUARTINA", "FARTURA", "GETULINA", "GUAIÇARA", "IACANGA", "IARAS", "IGARAÇU DO TIETÊ", "ITAÍ", "ITAJU", "ITAPORANGA", "ITAPUÍ", "ITATINGA", "JAÚ", "LARANJAL PAULISTA", "LENÇÓIS PAULISTA", "LINS", "LUCIANÓPOLIS",
                  "MACATUBA", "MANDURI", "MINEIROS DO TIETÊ", "PARANAPANEMA", "PARDINHO", "PAULISTÂNIA", "PEDERNEIRAS", "PEREIRAS", "PIRAJU", "PIRAJUÍ", "PIRATININGA", "PONGAÍ", "PORANGABA", "PRATÂNIA", "PRESIDENTE ALVES", "PROMISSÃO", "REGINÓPOLIS", "SABINO", "SÃO MANUEL", "SARUTAIÁ", "TAGUAÍ", "TAQUARITUBA", "TEJUPÁ", "TORRE DE PEDRA", "TORRINHA", "URU"],
   'drs7_campinas': ["ÁGUAS DE LINDÓIA", "AMERICANA", "AMPARO", "ARTUR NOGUEIRA", "ATIBAIA", "BOM JESUS DOS PERDÕES", "BRAGANÇA PAULISTA", "CABREÚVA", "CAMPINAS", "CAMPO LIMPO PAULISTA", "COSMÓPOLIS", "HOLAMBRA", "HORTOLÂNDIA", "INDAIATUBA",
                     "ITATIBA", "ITUPEVA", "JAGUARIÚNA", "JARINU", "JOANÓPOLIS", "JUNDIAÍ", "LINDÓIA", "LOUVEIRA", "MONTE ALEGRE DO SUL", "MONTE MOR", "MORUNGABA", "NAZARÉ PAULISTA", "NOVA ODESSA", "PAULÍNIA", "PEDRA BELA", "PEDREIRA", "PINHALZINHO", "PIRACAIA", "SANTA BÁRBARA D'OESTE", "SANTO ANTÔNIO DA POSSE", "SERRA NEGRA", "SOCORRO", "SUMARÉ", "TUIUTI", "VALINHOS", "VARGEM", "VÁRZEA PAULISTA", "VINHEDO"],
   'drs8_franca': ["ARAMINA", "BURITIZAL", "CRISTAIS PAULISTA", "FRANCA", "GUARÁ", "IGARAPAVA", "IPUÃ", "ITIRAPUÃ", "ITUVERAVA", "JERIQUARA", "MIGUELÓPOLIS", "MORRO AGUDO", "NUPORANGA", "ORLÂNDIA", "PATROCÍNIO PAULISTA", "PEDREGULHO", "RESTINGA", "RIBEIRÃO CORRENTE", "RIFAINA", "SALES OLIVEIRA", "SÃO JOAQUIM DA BARRA", "SÃO JOSÉ DA BELA VISTA"],
   'drs9_marilia': ["ADAMANTINA", "ÁLVARO DE CARVALHO", "ALVINLÂNDIA", "ARCO ÍRIS", "ASSIS", "BASTOS", "BERNARDINO DE CAMPOS", "BORÁ", "CAMPOS NOVOS PAULISTA", "CÂNDIDO MOTA", "CANITAR", "CHAVANTES", "CRUZÁLIA", "ECHAPORÃ", "ESPÍRITO SANTO DO TURVO", "FERNÃO", "FLÓRIDA PAULISTA", "FLORÍNIA", "GÁLIA", "GARÇA", "GUAIMBÊ", "GUARANTÃ", "HERCULÂNDIA",
                    "IACRI", "IBIRAREMA", "INÚBIA PAULISTA", "IPAUSSU", "JÚLIO MESQUITA", "LUCÉLIA", "LUPÉRCIO", "LUTÉCIA", "MARACAÍ", "MARIÁPOLIS", "MARÍLIA", "OCAUÇU", "ÓLEO", "ORIENTE", "OSCAR BRESSANE", "OSVALDO CRUZ", "OURINHOS", "PACAEMBU", "PALMITAL", "PARAGUAÇU PAULISTA", "PARAPUÃ", "PEDRINHAS PAULISTA", "PLATINA", "POMPÉIA", "PRACINHA",
                    "QUEIROZ", "QUINTANA", "RIBEIRÃO DO SUL", "RINÓPOLIS", "SAGRES", "SALMOURÃO", "SALTO GRANDE", "SANTA CRUZ DO RIO PARDO", "SÃO PEDRO DO TURVO", "TARUMÃ", "TIMBURI", "TUPÃ", "UBIRAJARA", "VERA CRUZ"],
    'drs10_piracicaba': ["ÁGUAS DE SÃO PEDRO", "ANALÂNDIA", "ARARAS", "CAPIVARI", "CHARQUEADA", "CONCHAL", "CORDEIRÓPOLIS", "CORUMBATAÍ", "ELIAS FAUSTO", "ENGENHEIRO COELHO", "IPEÚNA", "IRACEMÁPOLIS", "ITIRAPINA", "LEME", "LIMEIRA", "MOMBUCA", "PIRACICABA", "PIRASSUNUNGA", "RAFARD", "RIO CLARO", "RIO DAS PEDRAS", "SALTINHO", "SANTA CRUZ DA CONCEIÇÃO", "SANTA GERTRUDES", "SANTA MARIA DA SERRA", "SÃO PEDRO"],
    'drs11_presidente_prudente': ["ALFREDO MARCONDES", "ÁLVARES MACHADO", "ANHUMAS", "CAIABU", "CAIUÁ", "DRACENA", "EMILIANÓPOLIS", "ESTRELA DO NORTE", "EUCLIDES DA CUNHA PAULISTA", "FLORA RICA", "IEPÊ", "INDIANA", "IRAPURU", "JOÃO RAMALHO", "JUNQUEIRÓPOLIS", "MARABÁ PAULISTA", "MARTINÓPOLIS", "MIRANTE DO PARANAPANEMA", "MONTE CASTELO", "NANTES", "NARANDIBA", "NOVA GUATAPORANGA", "OURO VERDE",
                                  "PANORAMA", "PAULICÉIA", "PIQUEROBI", "PIRAPOZINHO", "PRESIDENTE BERNARDES", "PRESIDENTE EPITÁCIO", "PRESIDENTE PRUDENTE", "PRESIDENTE VENCESLAU", "QUATÁ", "RANCHARIA", "REGENTE FEIJÓ", "RIBEIRÃO DOS ÍNDIOS", "ROSANA", "SANDOVALINA", "SANTA MERCEDES", "SANTO ANASTÁCIO", "SANTO EXPEDITO", "SÃO JOÃO DO PAU D'ALHO", "TACIBA", "TARABAI", "TEODORO SAMPAIO", "TUPI PAULISTA"],
    'drs12_registro': ["BARRA DO TURVO", "CAJATI", "CANANÉIA", "ELDORADO", "IGUAPE", "ILHA COMPRIDA", "IPORANGA", "ITARIRI", "JACUPIRANGA", "JUQUIÁ", "MIRACATU", "PARIQUERA-AÇU", "PEDRO DE TOLEDO", "REGISTRO", "SETE BARRAS"],
    'drs13_ribeirao_preto': ["ALTINÓPOLIS", "BARRINHA", "BATATAIS", "BRODOWSKI", "CAJURU", "CÁSSIA DOS COQUEIROS", "CRAVINHOS", "DUMONT", "GUARIBA", "GUATAPARÁ", "JABOTICABAL", "JARDINÓPOLIS", "LUÍS ANTÔNIO", "MONTE ALTO", "PITANGUEIRAS", "PONTAL", "PRADÓPOLIS", "RIBEIRÃO PRETO", "SANTA CRUZ DA ESPERANÇA", "SANTA RITA DO PASSA QUATRO", "SANTA ROSA DE VITERBO", "SANTO ANTÔNIO DA ALEGRIA", "SÃO SIMÃO", "SERRA AZUL", "SERRANA", "SERTÃOZINHO"],
    'drs14_sao_joao_da_boa_vista': ["AGUAÍ", "ÁGUAS DA PRATA", "CACONDE", "CASA BRANCA", "DIVINOLÂNDIA", "ESPÍRITO SANTO DO PINHAL", "ESTIVA GERBI", "ITAPIRA", "ITOBI", "MOCOCA", "MOGI GUAÇU", "MOGI MIRIM", "SANTA CRUZ DAS PALMEIRAS", "SANTO ANTÔNIO DO JARDIM", "SÃO JOÃO DA BOA VISTA", "SÃO JOSÉ DO RIO PARDO", "SÃO SEBASTIÃO DA GRAMA", "TAMBAÚ", "TAPIRATIBA", "VARGEM GRANDE DO SUL"],
    'drs15_sao_jose_do_rio_preto': ["ADOLFO", "ÁLVARES FLORENCE", "AMÉRICO DE CAMPOS", "APARECIDA D'OESTE", "ARIRANHA", "ASPÁSIA", "BADY BASSIT", "BÁLSAMO", "CARDOSO", "CATANDUVA", "CATIGUÁ", "CEDRAL", "COSMORAMA", "DIRCE REIS", "DOLCINÓPOLIS", "ELISIÁRIO", "EMBAÚBA", "ESTRELA D'OESTE", "FERNANDÓPOLIS", "FERNANDO PRESTES", "FLOREAL", "GASTÃO VIDIGAL", "GENERAL SALGADO", "GUAPIAÇU", "GUARANI D'OESTE",
                                    "IBIRÁ", "ICÉM", "INDIAPORÃ", "IPIGUÁ", "IRAPUÃ", "ITAJOBI", "JACI", "JALES", "JOSÉ BONIFÁCIO", "MACAUBAL", "MACEDÔNIA", "MAGDA", "MARAPOAMA", "MARINÓPOLIS", "MENDONÇA", "MERIDIANO", "MESÓPOLIS", "MIRA ESTRELA", "MIRASSOL", "MIRASSOLÂNDIA", "MONÇÕES", "MONTE APRAZÍVEL", "NEVES PAULISTA", "NHANDEARA", "NIPOÃ", "NOVA ALIANÇA", "NOVA CANAÃ PAULISTA", "NOVA GRANADA", "NOVAIS",
                                    "NOVO HORIZONTE", "ONDA VERDE", "ORINDIÚVA", "OUROESTE", "PALESTINA", "PALMARES PAULISTA", "PALMEIRA D'OESTE", "PARAÍSO", "PARANAPUÃ", "PARISI", "PAULO DE FARIA", "PEDRANÓPOLIS", "PINDORAMA", "PIRANGI", "PLANALTO", "POLONI", "PONTALINDA", "PONTES GESTAL", "POPULINA", "POTIRENDABA", "RIOLÂNDIA", "RUBINÉIA", "SALES", "SANTA ADÉLIA", "SANTA ALBERTINA", "SANTA CLARA D'OESTE",
                                    "SANTA FÉ DO SUL", "SANTA RITA D'OESTE", "SANTA SALETE", "SANTANA DA PONTE PENSA", "SÃO FRANCISCO", "SÃO JOÃO DAS DUAS PONTES", "SÃO JOÃO DE IRACEMA", "SÃO JOSÉ DO RIO PRETO", "SEBASTIANÓPOLIS DO SUL", "TABAPUÃ", "TANABI", "TRÊS FRONTEIRAS", "TURMALINA", "UBARANA", "UCHOA", "UNIÃO PAULISTA", "URÂNIA", "URUPÊS", "VALENTIM GENTIL", "VITÓRIA BRASIL", "VOTUPORANGA", "ZACARIAS"],
    'drs16_sorocaba': ["ALAMBARI", "ALUMÍNIO", "ANGATUBA", "APIAÍ", "ARAÇARIGUAMA", "ARAÇOIABA DA SERRA", "BARRA DO CHAPÉU", "BOITUVA", "BOM SUCESSO DE ITARARÉ", "BURI", "CAMPINA DO MONTE ALEGRE", "CAPÃO BONITO", "CAPELA DO ALTO", "CERQUILHO", "CESÁRIO LANGE", "GUAPIARA", "GUAREÍ",
                   "IBIÚNA", "IPERÓ", "ITABERÁ", "ITAÓCA", "ITAPETININGA", "ITAPEVA", "ITAPIRAPUÃ PAULISTA", "ITARARÉ", "ITU", "JUMIRIM", "MAIRINQUE", "NOVA CAMPINA", "PIEDADE", "PILAR DO SUL", "PORTO FELIZ", "QUADRA", "RIBEIRA", "RIBEIRÃO BRANCO", "RIBEIRÃO GRANDE", "RIVERSUL", "SALTO", "SALTO DE PIRAPORA", "SÃO MIGUEL ARCANJO", "SÃO ROQUE", "SARAPUÍ", "SOROCABA", "TAPIRAÍ", "TAQUARIVAÍ", "TATUÍ", "TIETÊ", "VOTORANTIM"],
    'drs17_taubate': ["APARECIDA", "ARAPEÍ", "AREIAS", "BANANAL", "CAÇAPAVA", "CACHOEIRA PAULISTA", "CAMPOS DO JORDÃO", "CANAS", "CARAGUATATUBA", "CRUZEIRO", "CUNHA", "GUARATINGUETÁ", "IGARATÁ", "ILHA BELA", "JACAREÍ", "JAMBEIRO", "LAGOINHA", "LAVRINHAS", "LORENA", "MONTEIRO LOBATO", "NATIVIDADE DA SERRA", "PARAIBUNA", "PINDAMONHANGABA", "PIQUETE", "POTIM", "QUELUZ", "REDENÇÃO DA SERRA", "ROSEIRA", "SANTA BRANCA", "SANTO ANTÔNIO DO PINHAL",
                  "SÃO BENTO DO SAPUCAÍ", "SÃO JOSÉ DO BARREIRO", "SÃO JOSÉ DOS CAMPOS", "SÃO LUIZ DO PARAITINGA", "SÃO SEBASTIÃO", "SILVEIRAS", "TAUBATÉ", "TREMEMBÉ", "UBATUBA"]
}


# Adicionar coluna DS ao DataFrame com valores nulos inicialmente
municipios_df['DS'] = pd.NA

# Atualizar o DataFrame com a nova coluna DS
for ds, municipios in drs_data.items():
    municipios_df.loc[municipios_df['Município'].str.upper().isin(municipios), 'DS'] = ds

# Verificar se a coluna DS foi preenchida corretamente
print(municipios_df[['Município', 'DS']].head(10))


# Normalizar os nomes dos municípios para garantir correspondência
municipios_df['Municipio_normalizado'] = municipios_df['Município'].str.upper().str.normalize('NFKD').str.encode('ascii', errors='ignore').str.decode('utf-8')
process_count['comarca_normalizada'] = process_count['comarca'].str.upper().str.normalize('NFKD').str.encode('ascii', errors='ignore').str.decode('utf-8')

# Adicionar dados do DataFrame process_count ao municipios_df
municipios_df['Assunto'] = None
municipios_df['Count'] = 0
municipios_df['Coordinates'] = None

for idx, row in process_count.iterrows():
    municipio = row['comarca_normalizada']
    assunto = row['assunto']
    count = row['count']
    coords = row['coordinates']

    municipios_df.loc[municipios_df['Municipio_normalizado'] == municipio, 'Assunto'] = assunto
    municipios_df.loc[municipios_df['Municipio_normalizado'] == municipio, 'Count'] = count
    municipios_df.loc[municipios_df['Municipio_normalizado'] == municipio, 'Coordinates'] = str(coords)

# Verificar se os dados foram adicionados corretamente
print(municipios_df[['Município', 'Assunto', 'Count', 'Coordinates']].head())


# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_ds_assunto = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar os municípios por DS e definir cores para cada DS
ds_unique = municipios_df['DS'].unique()
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'brown', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']

ds_colors = {ds: colors[i % len(colors)] for i, ds in enumerate(ds_unique)}

# Adicionar entrada padrão ao dicionário assunto_to_color
default_color = '#00ff00'  # Cor padrão (verde)
assunto_to_color = {**assunto_to_color, **{assunto: default_color for assunto in process_count['assunto'].unique() if assunto not in assunto_to_color}}

# Criar FeatureGroups para cada DS e assunto
feature_groups_ds = {ds: FeatureGroup(name=f"Divisão de Saúde: {ds}", show=False) for ds in ds_unique}
feature_groups_assunto = {assunto: FeatureGroup(name=f"Assunto: {assunto}", show=False) for assunto in assunto_to_color.keys()}

# Adicionar FeatureGroups ao mapa
for fg in feature_groups_ds.values():
    fg.add_to(mapa_sp_ds_assunto)
for fg in feature_groups_assunto.values():
    fg.add_to(mapa_sp_ds_assunto)

# Adicionar marcadores e polígonos ao mapa
for ds, group in municipios_df.groupby('DS'):
    coords = group[['Latitude', 'Longitude']].values.tolist()
    folium.Polygon(
        locations=coords,
        popup=f"Divisão de Saúde: {ds}",
        color=ds_colors[ds],
        fill=True,
        fill_color=ds_colors[ds],
        fill_opacity=0.4
    ).add_to(feature_groups_ds[ds])

    for idx, row in group.iterrows():
        if pd.notna(row['Coordinates']):
            marker_coords = ast.literal_eval(row['Coordinates'])
            marker = folium.Marker(
                location=marker_coords,
                popup=f"{row['Município']}: {row['DS']}<br>Assunto: {row['Assunto']}<br>Processos: {row['Count']}",
                tooltip=f"População 2020: {row['População 2020']}",
                icon=folium.Icon(color=assunto_to_color.get(row['Assunto'], default_color), icon='info-sign')
            )
            marker.add_to(feature_groups_ds[ds])
            marker.add_to(feature_groups_assunto[row['Assunto']])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_ds_assunto)

# Adicionar botão para alternar todas as camadas
toggle_js = """
<script>
    function toggleLayers() {
        document.querySelectorAll('.leaflet-control-layers-selector').forEach(function(layer) {
            layer.click();
        });
    }
</script>
<button onclick="toggleLayers();">Toggle All Layers</button>
"""

# Adicionar botão e script JS ao mapa
mapa_sp_ds_assunto.get_root().html.add_child(folium.Element(toggle_js))

# Salvar e mostrar o mapa
mapa_sp_ds_assunto.save('mapa_sp_ds_interactive_map_ds_assunto.html')
print("Mapa salvo como 'interactive_map_ds_assunto.html'")

mapa_sp_ds_pop



## Função para converter string de coordenadas em lista de floats
#def convert_coordinates(coord):
#    if isinstance(coord, str):
#        coord = coord.strip('()')  # Remover os parênteses
#        return [float(x) for x in coord.split(',')]
#    elif isinstance(coord, (tuple, list)) and len(coord) == 2:
#        return [float(x) for x in coord]
#    return None

# Converter coordenadas no DataFrame process_count
#process_count['coordinates'] = process_count['coordinates'].apply(convert_coordinates)

import pandas as pd
import folium
from folium import LayerControl, FeatureGroup
import ast

# Carregar dados do arquivo CSV
municipios_df = pd.read_excel('/content/drive/MyDrive/pos_doc_usp/analise/divisoes_regionais_esp.xlsx')

# Definir os municípios por DRS diretamente no código
drs_data = {
   'drs1': ["ARUJÁ", "BARUERI", "BIRITIBA-MIRIM", "CAIEIRAS", "CAJAMAR", "CARAPICUÍBA", "COTIA", "DIADEMA", "EMBU", "EMBU-GUAÇU", "FERRAZ DE VASCONCELOS", "FRANCISCO MORATO", "FRANCO DA ROCHA", "GUARAREMA", "GUARULHOS", "ITAPECERICA DA SERRA", "ITAPEVI", "ITAQUAQUECETUBA", "JANDIRA", "JUQUITIBA", "MAIRIPORÃ", "MAUÁ", "MOGI DAS CRUZES", "OSASCO", "PIRAPORA DO BOM JESUS", "POÁ", "RIBEIRÃO PIRES", "RIO GRANDE DA SERRA", "SALESÓPOLIS", "SANTA ISABEL", "SANTANA DE PARNAÍBA", "SANTO ANDRÉ", "SÃO BERNARDO DO CAMPO", "SÃO CAETANO DO SUL", "SÃO LOURENÇO DA SERRA", "SÃO PAULO", "SUZANO", "TABOÃO DA SERRA", "VARGEM GRANDE PAULISTA"],
   'drs2_araçatuba': ["ALTO ALEGRE", "ANDRADINA", "ARAÇATUBA", "AURIFLAMA", "AVANHANDAVA", "BARBOSA", "BENTO DE ABREU", "BILAC", "BIRIGUI", "BRAÚNA", "BREJO ALEGRE", "BURITAMA", "CASTILHO", "CLEMENTINA", "COROADOS", "GABRIEL MONTEIRO", "GLICÉRIO", "GUARAÇAÍ", "GUARARAPES", "GUZOLÂNDIA", "ILHA SOLTEIRA", "ITAPURA", "LAVÍNIA", "LOURDES", "LUIZIÂNIA", "MIRANDÓPOLIS", "MURUTINGA DO SUL", "NOVA CASTILHO", "NOVA INDEPENDÊNCIA", "NOVA LUZITÂNIA", "PENÁPOLIS", "PEREIRA BARRETO", "PIACATU", "RUBIÁCEA", "SANTO ANTÔNIO DO ARACANGUÁ", "SANTÓPOLIS DO AGUAPEÍ", "SUD MENNUCCI", "SUZANÁPOLIS", "TURIÚBA", "VALPARAÍSO"],
   'drs3_araraquara': ["MÉRICO BRASILIENSE", "ARARAQUARA", "BOA ESPERANÇA DO SUL", "BORBOREMA", "CÂNDIDO RODRIGUES", "DESCALVADO", "DOBRADA", "DOURADO", "GAVIÃO PEIXOTO", "IBATÉ", "IBITINGA", "ITÁPOLIS", "MATÃO", "MOTUCA", "NOVA EUROPA", "PORTO FERREIRA", "RIBEIRÃO BONITO", "RINCÃO", "SANTA ERNESTINA", "SANTA LÚCIA", "SÃO CARLOS", "TABATINGA", "TAQUARITINGA", "TRABIJU"],
   'drs4_baixa_santista': ["BERTIOGA", "CUBATÃO", "GUARUJÁ", "ITANHAÉM", "MONGAGUÁ", "PERUÍBE", "PRAIA GRANDE", "SANTOS", "SÃO VICENTE"],
   'drs5_barretos': ["ALTAIR", "BARRETOS", "BEBEDOURO", "CAJOBI", "COLINA", "COLÔMBIA", "GUAÍRA", "GUARACI", "JABORANDI", "MONTE AZUL", "PAULISTA", "OLÍMPIA", "SEVERÍNIA", "TAIAÇU", "TAIÚVA", "TAQUARAL", "TERRA ROXA", "VIRADOURO", "VISTA ALEGRE DO ALTO"],
   'drs6_bauru': ["ÁGUAS DE SANTA BÁRBARA", "AGUDOS", "ANHEMBI", "ARANDU", "AREALVA", "AREIÓPOLIS", "AVAÍ", "AVARÉ", "BALBINOS", "BARÃO DE ANTONINA", "BARIRI", "BARRA BONITA", "BAURU", "BOCAINA", "BOFETE", "BORACÉIA", "BOREBI", "BOTUCATU", "BROTAS", "CABRÁLIA PAULISTA", "CAFELÂNDIA", "CERQUEIRA CÉSAR", "CONCHAS", "CORONEL MACEDO", "DOIS CÓRREGOS",
                  "DUARTINA", "FARTURA", "GETULINA", "GUAIÇARA", "IACANGA", "IARAS", "IGARAÇU DO TIETÊ", "ITAÍ", "ITAJU", "ITAPORANGA", "ITAPUÍ", "ITATINGA", "JAÚ", "LARANJAL PAULISTA", "LENÇÓIS PAULISTA", "LINS", "LUCIANÓPOLIS",
                  "MACATUBA", "MANDURI", "MINEIROS DO TIETÊ", "PARANAPANEMA", "PARDINHO", "PAULISTÂNIA", "PEDERNEIRAS", "PEREIRAS", "PIRAJU", "PIRAJUÍ", "PIRATININGA", "PONGAÍ", "PORANGABA", "PRATÂNIA", "PRESIDENTE ALVES", "PROMISSÃO", "REGINÓPOLIS", "SABINO", "SÃO MANUEL", "SARUTAIÁ", "TAGUAÍ", "TAQUARITUBA", "TEJUPÁ", "TORRE DE PEDRA", "TORRINHA", "URU"],
   'drs7_campinas': ["ÁGUAS DE LINDÓIA", "AMERICANA", "AMPARO", "ARTUR NOGUEIRA", "ATIBAIA", "BOM JESUS DOS PERDÕES", "BRAGANÇA PAULISTA", "CABREÚVA", "CAMPINAS", "CAMPO LIMPO PAULISTA", "COSMÓPOLIS", "HOLAMBRA", "HORTOLÂNDIA", "INDAIATUBA",
                     "ITATIBA", "ITUPEVA", "JAGUARIÚNA", "JARINU", "JOANÓPOLIS", "JUNDIAÍ", "LINDÓIA", "LOUVEIRA", "MONTE ALEGRE DO SUL", "MONTE MOR", "MORUNGABA", "NAZARÉ PAULISTA", "NOVA ODESSA", "PAULÍNIA", "PEDRA BELA", "PEDREIRA", "PINHALZINHO", "PIRACAIA", "SANTA BÁRBARA D'OESTE", "SANTO ANTÔNIO DA POSSE", "SERRA NEGRA", "SOCORRO", "SUMARÉ", "TUIUTI", "VALINHOS", "VARGEM", "VÁRZEA PAULISTA", "VINHEDO"],
   'drs8_franca': ["ARAMINA", "BURITIZAL", "CRISTAIS PAULISTA", "FRANCA", "GUARÁ", "IGARAPAVA", "IPUÃ", "ITIRAPUÃ", "ITUVERAVA", "JERIQUARA", "MIGUELÓPOLIS", "MORRO AGUDO", "NUPORANGA", "ORLÂNDIA", "PATROCÍNIO PAULISTA", "PEDREGULHO", "RESTINGA", "RIBEIRÃO CORRENTE", "RIFAINA", "SALES OLIVEIRA", "SÃO JOAQUIM DA BARRA", "SÃO JOSÉ DA BELA VISTA"],
   'drs9_marilia': ["ADAMANTINA", "ÁLVARO DE CARVALHO", "ALVINLÂNDIA", "ARCO ÍRIS", "ASSIS", "BASTOS", "BERNARDINO DE CAMPOS", "BORÁ", "CAMPOS NOVOS PAULISTA", "CÂNDIDO MOTA", "CANITAR", "CHAVANTES", "CRUZÁLIA", "ECHAPORÃ", "ESPÍRITO SANTO DO TURVO", "FERNÃO", "FLÓRIDA PAULISTA", "FLORÍNIA", "GÁLIA", "GARÇA", "GUAIMBÊ", "GUARANTÃ", "HERCULÂNDIA",
                    "IACRI", "IBIRAREMA", "INÚBIA PAULISTA", "IPAUSSU", "JÚLIO MESQUITA", "LUCÉLIA", "LUPÉRCIO", "LUTÉCIA", "MARACAÍ", "MARIÁPOLIS", "MARÍLIA", "OCAUÇU", "ÓLEO", "ORIENTE", "OSCAR BRESSANE", "OSVALDO CRUZ", "OURINHOS", "PACAEMBU", "PALMITAL", "PARAGUAÇU PAULISTA", "PARAPUÃ", "PEDRINHAS PAULISTA", "PLATINA", "POMPÉIA", "PRACINHA",
                    "QUEIROZ", "QUINTANA", "RIBEIRÃO DO SUL", "RINÓPOLIS", "SAGRES", "SALMOURÃO", "SALTO GRANDE", "SANTA CRUZ DO RIO PARDO", "SÃO PEDRO DO TURVO", "TARUMÃ", "TIMBURI", "TUPÃ", "UBIRAJARA", "VERA CRUZ"],
    'drs10_piracicaba': ["ÁGUAS DE SÃO PEDRO", "ANALÂNDIA", "ARARAS", "CAPIVARI", "CHARQUEADA", "CONCHAL", "CORDEIRÓPOLIS", "CORUMBATAÍ", "ELIAS FAUSTO", "ENGENHEIRO COELHO", "IPEÚNA", "IRACEMÁPOLIS", "ITIRAPINA", "LEME", "LIMEIRA", "MOMBUCA", "PIRACICABA", "PIRASSUNUNGA", "RAFARD", "RIO CLARO", "RIO DAS PEDRAS", "SALTINHO", "SANTA CRUZ DA CONCEIÇÃO", "SANTA GERTRUDES", "SANTA MARIA DA SERRA", "SÃO PEDRO"],
    'drs11_presidente_prudente': ["ALFREDO MARCONDES", "ÁLVARES MACHADO", "ANHUMAS", "CAIABU", "CAIUÁ", "DRACENA", "EMILIANÓPOLIS", "ESTRELA DO NORTE", "EUCLIDES DA CUNHA PAULISTA", "FLORA RICA", "IEPÊ", "INDIANA", "IRAPURU", "JOÃO RAMALHO", "JUNQUEIRÓPOLIS", "MARABÁ PAULISTA", "MARTINÓPOLIS", "MIRANTE DO PARANAPANEMA", "MONTE CASTELO", "NANTES", "NARANDIBA", "NOVA GUATAPORANGA", "OURO VERDE",
                                  "PANORAMA", "PAULICÉIA", "PIQUEROBI", "PIRAPOZINHO", "PRESIDENTE BERNARDES", "PRESIDENTE EPITÁCIO", "PRESIDENTE PRUDENTE", "PRESIDENTE VENCESLAU", "QUATÁ", "RANCHARIA", "REGENTE FEIJÓ", "RIBEIRÃO DOS ÍNDIOS", "ROSANA", "SANDOVALINA", "SANTA MERCEDES", "SANTO ANASTÁCIO", "SANTO EXPEDITO", "SÃO JOÃO DO PAU D'ALHO", "TACIBA", "TARABAI", "TEODORO SAMPAIO", "TUPI PAULISTA"],
    'drs12_registro': ["BARRA DO TURVO", "CAJATI", "CANANÉIA", "ELDORADO", "IGUAPE", "ILHA COMPRIDA", "IPORANGA", "ITARIRI", "JACUPIRANGA", "JUQUIÁ", "MIRACATU", "PARIQUERA-AÇU", "PEDRO DE TOLEDO", "REGISTRO", "SETE BARRAS"],
    'drs13_ribeirao_preto': ["ALTINÓPOLIS", "BARRINHA", "BATATAIS", "BRODOWSKI", "CAJURU", "CÁSSIA DOS COQUEIROS", "CRAVINHOS", "DUMONT", "GUARIBA", "GUATAPARÁ", "JABOTICABAL", "JARDINÓPOLIS", "LUÍS ANTÔNIO", "MONTE ALTO", "PITANGUEIRAS", "PONTAL", "PRADÓPOLIS", "RIBEIRÃO PRETO", "SANTA CRUZ DA ESPERANÇA", "SANTA RITA DO PASSA QUATRO", "SANTA ROSA DE VITERBO", "SANTO ANTÔNIO DA ALEGRIA", "SÃO SIMÃO", "SERRA AZUL", "SERRANA", "SERTÃOZINHO"],
    'drs14_sao_joao_da_boa_vista': ["AGUAÍ", "ÁGUAS DA PRATA", "CACONDE", "CASA BRANCA", "DIVINOLÂNDIA", "ESPÍRITO SANTO DO PINHAL", "ESTIVA GERBI", "ITAPIRA", "ITOBI", "MOCOCA", "MOGI GUAÇU", "MOGI MIRIM", "SANTA CRUZ DAS PALMEIRAS", "SANTO ANTÔNIO DO JARDIM", "SÃO JOÃO DA BOA VISTA", "SÃO JOSÉ DO RIO PARDO", "SÃO SEBASTIÃO DA GRAMA", "TAMBAÚ", "TAPIRATIBA", "VARGEM GRANDE DO SUL"],
    'drs15_sao_jose_do_rio_preto': ["ADOLFO", "ÁLVARES FLORENCE", "AMÉRICO DE CAMPOS", "APARECIDA D'OESTE", "ARIRANHA", "ASPÁSIA", "BADY BASSIT", "BÁLSAMO", "CARDOSO", "CATANDUVA", "CATIGUÁ", "CEDRAL", "COSMORAMA", "DIRCE REIS", "DOLCINÓPOLIS", "ELISIÁRIO", "EMBAÚBA", "ESTRELA D'OESTE", "FERNANDÓPOLIS", "FERNANDO PRESTES", "FLOREAL", "GASTÃO VIDIGAL", "GENERAL SALGADO", "GUAPIAÇU", "GUARANI D'OESTE",
                                    "IBIRÁ", "ICÉM", "INDIAPORÃ", "IPIGUÁ", "IRAPUÃ", "ITAJOBI", "JACI", "JALES", "JOSÉ BONIFÁCIO", "MACAUBAL", "MACEDÔNIA", "MAGDA", "MARAPOAMA", "MARINÓPOLIS", "MENDONÇA", "MERIDIANO", "MESÓPOLIS", "MIRA ESTRELA", "MIRASSOL", "MIRASSOLÂNDIA", "MONÇÕES", "MONTE APRAZÍVEL", "NEVES PAULISTA", "NHANDEARA", "NIPOÃ", "NOVA ALIANÇA", "NOVA CANAÃ PAULISTA", "NOVA GRANADA", "NOVAIS",
                                    "NOVO HORIZONTE", "ONDA VERDE", "ORINDIÚVA", "OUROESTE", "PALESTINA", "PALMARES PAULISTA", "PALMEIRA D'OESTE", "PARAÍSO", "PARANAPUÃ", "PARISI", "PAULO DE FARIA", "PEDRANÓPOLIS", "PINDORAMA", "PIRANGI", "PLANALTO", "POLONI", "PONTALINDA", "PONTES GESTAL", "POPULINA", "POTIRENDABA", "RIOLÂNDIA", "RUBINÉIA", "SALES", "SANTA ADÉLIA", "SANTA ALBERTINA", "SANTA CLARA D'OESTE",
                                    "SANTA FÉ DO SUL", "SANTA RITA D'OESTE", "SANTA SALETE", "SANTANA DA PONTE PENSA", "SÃO FRANCISCO", "SÃO JOÃO DAS DUAS PONTES", "SÃO JOÃO DE IRACEMA", "SÃO JOSÉ DO RIO PRETO", "SEBASTIANÓPOLIS DO SUL", "TABAPUÃ", "TANABI", "TRÊS FRONTEIRAS", "TURMALINA", "UBARANA", "UCHOA", "UNIÃO PAULISTA", "URÂNIA", "URUPÊS", "VALENTIM GENTIL", "VITÓRIA BRASIL", "VOTUPORANGA", "ZACARIAS"],
    'drs16_sorocaba': ["ALAMBARI", "ALUMÍNIO", "ANGATUBA", "APIAÍ", "ARAÇARIGUAMA", "ARAÇOIABA DA SERRA", "BARRA DO CHAPÉU", "BOITUVA", "BOM SUCESSO DE ITARARÉ", "BURI", "CAMPINA DO MONTE ALEGRE", "CAPÃO BONITO", "CAPELA DO ALTO", "CERQUILHO", "CESÁRIO LANGE", "GUAPIARA", "GUAREÍ",
                   "IBIÚNA", "IPERÓ", "ITABERÁ", "ITAÓCA", "ITAPETININGA", "ITAPEVA", "ITAPIRAPUÃ PAULISTA", "ITARARÉ", "ITU", "JUMIRIM", "MAIRINQUE", "NOVA CAMPINA", "PIEDADE", "PILAR DO SUL", "PORTO FELIZ", "QUADRA", "RIBEIRA", "RIBEIRÃO BRANCO", "RIBEIRÃO GRANDE", "RIVERSUL", "SALTO", "SALTO DE PIRAPORA", "SÃO MIGUEL ARCANJO", "SÃO ROQUE", "SARAPUÍ", "SOROCABA", "TAPIRAÍ", "TAQUARIVAÍ", "TATUÍ", "TIETÊ", "VOTORANTIM"],
    'drs17_taubate': ["APARECIDA", "ARAPEÍ", "AREIAS", "BANANAL", "CAÇAPAVA", "CACHOEIRA PAULISTA", "CAMPOS DO JORDÃO", "CANAS", "CARAGUATATUBA", "CRUZEIRO", "CUNHA", "GUARATINGUETÁ", "IGARATÁ", "ILHA BELA", "JACAREÍ", "JAMBEIRO", "LAGOINHA", "LAVRINHAS", "LORENA", "MONTEIRO LOBATO", "NATIVIDADE DA SERRA", "PARAIBUNA", "PINDAMONHANGABA", "PIQUETE", "POTIM", "QUELUZ", "REDENÇÃO DA SERRA", "ROSEIRA", "SANTA BRANCA", "SANTO ANTÔNIO DO PINHAL",
                  "SÃO BENTO DO SAPUCAÍ", "SÃO JOSÉ DO BARREIRO", "SÃO JOSÉ DOS CAMPOS", "SÃO LUIZ DO PARAITINGA", "SÃO SEBASTIÃO", "SILVEIRAS", "TAUBATÉ", "TREMEMBÉ", "UBATUBA"]
}

# Adicionar coluna DS ao DataFrame com valores nulos inicialmente
municipios_df['DS'] = pd.NA

# Atualizar o DataFrame com a nova coluna DS
for ds, municipios in drs_data.items():
    municipios_df.loc[municipios_df['Município'].str.upper().isin(municipios), 'DS'] = ds

# Verificar se a coluna DS foi preenchida corretamente
print(municipios_df[['Município', 'DS']].head(10))

# Normalizar os nomes dos municípios para garantir correspondência
municipios_df['Municipio_normalizado'] = municipios_df['Município'].str.upper().str.normalize('NFKD').str.encode('ascii', errors='ignore').str.decode('utf-8')
process_count['comarca_normalizada'] = process_count['comarca'].str.upper().str.normalize('NFKD').str.encode('ascii', errors='ignore').str.decode('utf-8')

# Adicionar dados do DataFrame process_count ao municipios_df
municipios_df['Assunto'] = None
municipios_df['Count'] = 0
municipios_df['Coordinates'] = None

for idx, row in process_count.iterrows():
    municipio = row['comarca_normalizada']
    assunto = row['assunto']
    count = row['count']
    coords = row['coordinates']

    # Atualizar apenas o último valor válido de assunto
    municipios_df.loc[municipios_df['Municipio_normalizado'] == municipio, 'Assunto'] = assunto
    municipios_df.loc[municipios_df['Municipio_normalizado'] == municipio, 'Count'] += count
    municipios_df.loc[municipios_df['Municipio_normalizado'] == municipio, 'Coordinates'] = str(coords)

# Verificar se os dados foram adicionados corretamente
print(municipios_df[['Município', 'Assunto', 'Count', 'Coordinates']].head())

# Coordenadas aproximadas para o centro do Estado de São Paulo
centro_sp = [-23.550520, -46.633308]  # Coordenadas de São Paulo, SP

# Criar o mapa base, focado no Estado de São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_ds_pop = folium.Map(location=centro_sp, zoom_start=7)

# Agrupar os municípios por DS e definir cores para cada DS
ds_unique = municipios_df['DS'].unique()
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'brown', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']

ds_colors = {ds: colors[i % len(colors)] for i, ds in enumerate(ds_unique)}

# Adicionar entrada padrão ao dicionário assunto_to_color
default_color = 'blue'  # Cor padrão
assunto_to_color = {**assunto_to_color, **{assunto: default_color for assunto in process_count['assunto'].unique() if assunto not in assunto_to_color}}

# Criar FeatureGroups para cada DS e assunto
feature_groups_ds = {ds: FeatureGroup(name=f"Divisão de Saúde: {ds}", show=False) for ds in ds_unique}
feature_groups_assunto = {assunto: FeatureGroup(name=f"Assunto: {assunto}", show=False) for assunto in assunto_to_color.keys()}

# Adicionar FeatureGroups ao mapa
for fg in feature_groups_ds.values():
    fg.add_to(mapa_sp_ds_pop)
for fg in feature_groups_assunto.values():
    fg.add_to(mapa_sp_ds_pop)

# Ordenar os municípios dentro de cada DS por população
for ds, group in municipios_df.groupby('DS'):
    # Ordenar pelos valores de população, por exemplo, em ordem decrescente
    group_sorted = group.sort_values(by='População 2020', ascending=False)
    coords = group_sorted[['Latitude', 'Longitude']].values.tolist()

    # Adicionar polígono ao mapa
    folium.Polygon(
        locations=coords,
        popup=f"Divisão de Saúde: {ds}",
        color=ds_colors[ds],
        fill=True,
        fill_color=ds_colors[ds],
        fill_opacity=0.4
    ).add_to(feature_groups_ds[ds])

    # Adicionar marcadores
    for idx, row in group_sorted.iterrows():
        folium.Marker(
            location=[row['Latitude'], row['Longitude']],
            popup=f"{row['Município']}: {row['DS']}<br>Assunto: {row['Assunto']}<br>Processos: {row['Count']}",
            tooltip=f"População 2020: {row['População 2020']}",
            icon=folium.Icon(color='blue', icon='info-sign')
        ).add_to(feature_groups_ds[ds])
        if row['Assunto'] is not None:
            folium.Marker(
                location=[row['Latitude'], row['Longitude']],
                popup=f"{row['Município']}: {row['DS']}<br>Assunto: {row['Assunto']}<br>Processos: {row['Count']}",
                tooltip=f"População 2020: {row['População 2020']}",
                icon=folium.Icon(color='blue', icon='info-sign')
            ).add_to(feature_groups_assunto[row['Assunto']])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_ds_pop)

# Adicionar botão para alternar todas as camadas
toggle_js = """
<script>
    function toggleLayers() {
        document.querySelectorAll('.leaflet-control-layers-selector').forEach(function(layer) {
            layer.click();
        });
    }
</script>
<button onclick="toggleLayers();">Toggle All Layers</button>
"""

# Adicionar botão e script JS ao mapa
mapa_sp_ds_pop.get_root().html.add_child(folium.Element(toggle_js))

# Salvar e mostrar o mapa
mapa_sp_ds_pop.save('interactive_map_ds_assunto.html')

municipios_df.head(20)

mapa_sp_ds_pop

"""Mapa com os magistrados"""

# Coordenadas aproximadas para o centro de São Paulo
centro_sp = [-23.550520, -46.633308]  # Centro de São Paulo, SP

# Criar o mapa base, focado em São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp_alternativo = folium.Map(location=centro_sp, zoom_start=7)
marker_cluster = MarkerCluster().add_to(mapa_sp_alternativo)

# Criar FeatureGroups para assuntos, magistrados e municípios
assunto_groups = {}
magistrado_groups = {}
municipio_groups = {}

# Adicionando FeatureGroups ao mapa
for idx, row in top_magistrados.iterrows():
    assunto = row['assunto']
    magistrado = row['magistrado']
    municipio = row['comarca']

    if assunto not in assunto_groups:
        assunto_groups[assunto] = FeatureGroup(name=f"Assunto: {assunto}", show=True).add_to(marker_cluster)
    if magistrado not in magistrado_groups:
        magistrado_groups[magistrado] = FeatureGroup(name=f"Magistrado: {magistrado}", show=True).add_to(marker_cluster)
    if municipio not in municipio_groups:
        municipio_groups[municipio] = FeatureGroup(name=f"Município: {municipio}", show=True).add_to(marker_cluster)

    # Adicionar marcadores a cada grupo
    marker = folium.CircleMarker(
        location=row['coordinates'],
        radius=5,
        popup=f"{municipio}: {assunto} ({row['count']} processos), Magistrado: {magistrado}",
        color=assunto_to_color[assunto],
        fill=True,
        fill_color=assunto_to_color[assunto]
    )
    marker.add_to(assunto_groups[assunto])
    marker.add_to(magistrado_groups[magistrado])
    marker.add_to(municipio_groups[municipio])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp_alternativo)


# Salvar e mostrar mapa
mapa_sp_alternativo.save('/content/drive/MyDrive/pos_doc_usp/analise/interactive_map_sao_paulo_alternativo.html')
print("Mapa salvo como 'interactive_map_sao_paulo.html'")

mapa_sp_ds_pop

import folium
from folium.plugins import MarkerCluster
from folium import LayerControl, FeatureGroup

# Coordenadas aproximadas para o centro de São Paulo
centro_sp = [-23.550520, -46.633308]  # Centro de São Paulo, SP

# Criar o mapa base, focado em São Paulo com um zoom inicial que mostre claramente o estado
mapa_sp = folium.Map(location=centro_sp, zoom_start=7)
marker_cluster = MarkerCluster().add_to(mapa_sp)

# Criar FeatureGroups para assuntos, magistrados e municípios
assunto_groups = {}
magistrado_groups = {}
municipio_groups = {}

# Cor padrão para assuntos não mapeados
default_color = 'gray'

# Adicionando FeatureGroups ao mapa
for idx, row in top_magistrados.iterrows():
    assunto = row['assunto']
    magistrado = row['magistrado']
    municipio = row['comarca']

    if assunto not in assunto_groups:
        assunto_groups[assunto] = FeatureGroup(name=f"Assunto: {assunto}", show=True).add_to(marker_cluster)
    if magistrado not in magistrado_groups:
        magistrado_groups[magistrado] = FeatureGroup(name=f"Magistrado: {magistrado}", show=True).add_to(marker_cluster)
    if municipio not in municipio_groups:
        municipio_groups[municipio] = FeatureGroup(name=f"Município: {municipio}", show=True).add_to(marker_cluster)

    # Adicionar marcadores a cada grupo
    marker = folium.CircleMarker(
        location=row['coordinates'],
        radius=5,
        popup=f"{municipio}: {assunto} ({row['count']} processos), Magistrado: {magistrado}",
        color=assunto_to_color.get(assunto, default_color),  # Usa a cor do dicionário ou a cor padrão
        fill=True,
        fill_color=assunto_to_color.get(assunto, default_color)  # Usa a cor do dicionário ou a cor padrão
    )
    marker.add_to(assunto_groups[assunto])
    marker.add_to(magistrado_groups[magistrado])
    marker.add_to(municipio_groups[municipio])

# Adicionar controle de camadas para alternar visualizações
LayerControl(collapsed=False).add_to(mapa_sp)

# Salvar e mostrar mapa
mapa_sp.save('interactive_map_sao_paulo.html')
print("Mapa salvo como 'interactive_map_sao_paulo.html'")

"""# Trabalhando com o GEOPANDAS"""

!pip install geopandas
!pip install descartes

import geopandas as gpd
import descartes
sp_esp = gpd.read_file('/content/IDHM/')

sp_esp.plot()





"""##PLOTAGEM GERAL

##Capturando dados do maps
"""

# Configurar cliente do Google Maps
#gmaps = googlemaps.Client(key='AIzaSyAvqU8-togmlAdibLlfdz6YpgN5cVD7d54')

# Função para obter coordenadas
#def get_coordinates(city):
#    try:
#        geocode_result = gmaps.geocode(city + ', Brazil')
#        if geocode_result:
#            lat = geocode_result[0]['geometry']['location']['lat']
#            lng = geocode_result[0]['geometry']['location']['lng']
#            return (lat, lng)
#    except Exception as e:
#        print(f"Error fetching coordinates for {city}: {str(e)}")
#        return None  # Retorna None se houver erro

# Aplicar a função de coordenadas e garantir que ela está sendo aplicada corretamente
process_count['coordinates'] = process_count['comarca'].apply(get_coordinates)

# Verificar se há alguma entrada None nas coordenadas
print("Entries with no coordinates:", process_count['coordinates'].isnull().sum())

# Adicionando coordenadas ao DataFrame
process_count['coordinates'] = process_count['comarca'].apply(get_coordinates)

# Garantindo que a coluna 'assunto' está truncada
process_count['assunto'] = process_count['assunto'].apply(lambda x: x[:35] if isinstance(x, str) else x)

# Agrupando dados por 'comarca', 'magistrado', 'assunto' e sumarizando 'count'
grouped_data = process_count.groupby(['comarca', 'magistrado', 'assunto']).agg({'count': 'sum'}).reset_index()

# Selecionando os top 50 magistrados com base no número de processos
top_magistrados = grouped_data.sort_values(by='count', ascending=False).head(50)

# Garantindo que 'coordinates' seja incluída no DataFrame final
top_magistrados = grouped_data.sort_values(by='count', ascending=False).head(50)
top_magistrados = top_magistrados.merge(process_count[['comarca', 'coordinates']], on='comarca', how='left')

# Criar uma paleta de cores para os assuntos
unique_assuntos = grouped_data['assunto'].unique()
colors = sns.color_palette('hsv', len(unique_assuntos)).as_hex()
assunto_to_color = dict(zip(unique_assuntos, colors))

# Mapeamento de magistrados para formas
unique_magistrados = top_magistrados['magistrado'].unique()
shapes = ['circle', 'triangle', 'square', 'star'] * (len(unique_magistrados) // 4 + 1)  # Garantir suficiente repetição
magistrado_to_shape = dict(zip(unique_magistrados, shapes))

top_magistrados.head()

# Remover colchetes das coordenadas
def remove_brackets(coord_str):
    if isinstance(coord_str, str):
        return tuple(coord_str.strip('[]').split(', '))
    else:
        return coord_str

# Remover colchetes das coordenadas
top_magistrados['coordinates'] = top_magistrados['coordinates'].apply(remove_brackets)

# Função para converter coordenadas para listas de floats [latitude, longitude]
def convert_coordinates(coord):
    if isinstance(coord, str):
        return [float(c) for c in coord.split(',')]
    elif isinstance(coord, list) and len(coord) == 2:
        return [float(c) for c in coord]
    return None

# Aplicar a função de conversão na coluna 'coordinates'
process_count['coordinates'] = process_count['coordinates'].apply(convert_coordinates)

top_magistrados

# Criar o mapa base
centro_sp = [-23.550520, -46.633308]  # Centro de São Paulo, SP

# Criar o mapa base, focado em São Paulo com um zoom inicial que mostre claramente o estado
m = folium.Map(location=centro_sp, zoom_start=7)

#m = folium.Map(location=[-15.788497, -47.879873], zoom_start=5)


magistrado_to_shape = {row['magistrado']: 'circle' for _, row in process_count.iterrows()}
colors = ['red', 'blue', 'green', 'purple', 'orange']
sizes = [5, 10, 15, 20, 25]

# Adicionar pontos ao mapa
for idx, row in process_count.iterrows():
    coords = row['coordinates']
    if isinstance(coords, list) and len(coords) == 2:  # Verificar se as coordenadas são válidas
        shape = magistrado_to_shape.get(row['magistrado'], 'circle')  # Usar 'circle' como valor padrão
        color = colors[idx % len(colors)]
        size = sizes[idx % len(sizes)]

        popup_text = f"{row['comarca']}: {row['assunto']} ({row['count']} processos)"
        if shape == 'circle':
            marker = folium.CircleMarker(
                location=coords,
                radius=size,
                popup=popup_text,
                color=color,
                fill=True,
                fill_color=color
            )
        else:
            sides = 3 + (idx % 8)  # Variar o número de lados para diferentes polígonos
            marker = folium.RegularPolygonMarker(
                location=coords,
                number_of_sides=sides,
                radius=size,
                popup=popup_text,
                color=color,
                fill_color=color
            )
        marker.add_to(m)


# Salvar e mostrar mapa
m.save('map_customized.html')

m

m

from folium.plugins import MarkerCluster, FeatureGroupSubGroup

# Criar o mapa base
m = folium.Map(location=[-15.788497, -47.879873], zoom_start=5, tiles = 'Stamen Toner')
marker_cluster = MarkerCluster().add_to(m)  # Adiciona agrupamento de marcadores

# Criação de grupos de recursos por categoria
feature_groups = {assunto: FeatureGroupSubGroup(marker_cluster, name=assunto) for assunto in unique_assuntos}
for fg in feature_groups.values():
    fg.add_to(m)

# Adicionar marcadores ao mapa com filtro por categoria
for idx, row in top_magistrados.iterrows():
    coords = row['coordinates']
    # Verificar se as coordenadas são válidas: lista de dois elementos e nenhum deles é NaN
    if isinstance(coords, list) and len(coords) == 2 and all(pd.notna(coord) for coord in coords):
        group = feature_groups.get(row['assunto'], marker_cluster)  # Usar 'marker_cluster' como valor padrão se o assunto não estiver presente
        color = assunto_to_color.get(row['assunto'], default_color)  # Usar 'default_color' se o assunto não estiver presente

        folium.CircleMarker(
            location=coords,
            radius=sizes[idx % len(sizes)],
            popup=f"{row['comarca']}: {row['assunto']} ({row['count']} processos)",
            color=color,
            fill=True,
            fill_color=color
        ).add_to(group)

# Adicionar legenda (opcional, você pode customizar mais se necessário)
folium.map.LayerControl('topright', collapsed=False).add_to(m)

# Salvar e mostrar mapa
m.save('map_customized_with_filters.html')

m

from folium.plugins import HeatMap

# Criar o mapa base para o heatmap
heatmap_map = folium.Map(location= [-23.550520, -46.633308], zoom_start=7)

# Preparar dados para o heatmap
heatmap_data = [
    (row['coordinates'][0], row['coordinates'][1], row['count'])
    for idx, row in top_magistrados.iterrows()
    if isinstance(row['coordinates'], list) and len(row['coordinates']) == 2 and all(pd.notna(coord) for coord in row['coordinates'])
]

# Adicionar o HeatMap ao mapa
HeatMap(heatmap_data, radius=15, max_zoom=1).add_to(heatmap_map)

process_count

heatmap_map

# Coordenadas aproximadas para o centro do estado de São Paulo
centro_sp = [-22.0, -48.0]  # Coordenadas aproximadas do centro do estado de São Paulo
heatmap_map = folium.Map(location=centro_sp, zoom_start=7)

# Preparar dados para o heatmap
heatmap_data = [
    (row['coordinates'][0], row['coordinates'][1], row['count'])
    for idx, row in top_magistrados.iterrows()
    if isinstance(row['coordinates'], list) and len(row['coordinates']) == 2 and all(pd.notna(coord) for coord in row['coordinates'])
]

# Adicionar o HeatMap ao mapa
HeatMap(heatmap_data, radius=15, max_zoom=1).add_to(heatmap_map)

# Salvar e mostrar o mapa de calor
heatmap_map.save('heatmap_sao_paulo.html')
print("Mapa de calor salvo como 'heatmap_sao_paulo.html'")

"""### Filtros com legenda

Feature Groups: Cada categoria de assunto tem seu próprio FeatureGroup, o que permite aos usuários filtrar no mapa quais categorias eles desejam ver.

Layer Control: Adiciona uma interface no mapa para o usuário poder ligar e desligar a visibilidade de cada grupo de marcadores.

Legenda: Uma legenda HTML é adicionada ao mapa para ajudar a entender o que cada elemento gráfico representa.

Pop-ups (Hoover): Os pop-ups (chamados aqui de "hoover") são configurados para mostrar ao passar o mouse ou clicar sobre um marcador, detalhando a comarca, assunto e count de processos.

 botão "Todos" usando um bloco de HTML e JavaScript diretamente incorporados na página. Este código vai alternar todas as camadas baseado na interface de usuário de folium. Vou mostrar como ajustar isso dentro da capacidade de folium:

"""

# Filtrar apenas assuntos relacionados a câncer
unique_assuntos = top_magistrados['assunto'].unique()
sizes = [5, 10, 15, 20, 25]
assunto_to_color = {assunto: color for assunto, color in zip(unique_assuntos, ['red', 'blue', 'green', 'purple', 'orange'])}

# Criar o mapa base
centro_sp = [-22.0, -48.0]  # Coordenadas aproximadas do centro do estado de São Paulo
m = folium.Map(location=centro_sp, zoom_start=7, tiles='Stamen Toner')
marker_cluster = MarkerCluster().add_to(m)

# Preparação e adição de FeatureGroups para assuntos e comarcas
assunto_groups = {}
for assunto in unique_assuntos:
    if top_magistrados[top_magistrados['assunto'] == assunto].shape[0] > 0:  # Verificar se há processos
        group = folium.FeatureGroup(name=assunto, show=False)
        assunto_groups[assunto] = group
        group.add_to(m)

# Adicionar marcadores ao mapa
for idx, row in top_magistrados.iterrows():
    coords = row['coordinates']
    if isinstance(coords, list) and len(coords) == 2 and all(pd.notna(coord) for coord in coords):
        group = assunto_groups.get(row['assunto'])
        if group:
            folium.CircleMarker(
                location=coords,
                radius=5,
                popup=f"{row['comarca']}: {row['assunto']} ({row['count']} processos)",
                color=assunto_to_color.get(row['assunto'], 'gray'),
                fill=True,
                fill_color=assunto_to_color.get(row['assunto'], 'gray')
            ).add_to(group)

# JavaScript para alternar todas as camadas
toggle_js = """
<script>
    function toggleLayers() {
        var checkboxes = document.getElementsByClassName('leaflet-control-layers-selector');
        for (var i = 0; i < checkboxes.length; i++) {
            if (checkboxes[i].checked !== true) {
                checkboxes[i].click();
            }
        }
    }
</script>
<button onclick="toggleLayers();">Toggle All Layers</button>
"""

# Adicionar botão e script JS ao mapa
m.get_root().html.add_child(folium.Element(toggle_js))

# Adicionar controle de camadas
LayerControl(collapsed=False).add_to(m)

# Salvar e mostrar o mapa
m.save('interactive_map_with_filters_and_legend.html')
print("Mapa interativo com filtros e legenda salvo como 'interactive_map_with_filters_and_legend.html'")

m

m





from folium.plugins import MarkerCluster
from folium import FeatureGroup, LayerControl

# Criar o mapa base
m = folium.Map(location=[-15.788497, -47.879873], zoom_start=5)
marker_cluster = MarkerCluster().add_to(m)  # Agrupamento de marcadores

# Criação de grupos de recursos por categoria
feature_groups = {}
for assunto in unique_assuntos:
    group = FeatureGroup(name=assunto, show=False)  # O parâmetro show=False inicializa o grupo como oculto
    feature_groups[assunto] = group
    group.add_to(m)

# Adicionar marcadores ao mapa com filtro por categoria
for idx, row in top_magistrados.iterrows():
    if pd.notna(row['coordinates']):
        group = feature_groups[row['assunto']]
        folium.CircleMarker(
            location=row['coordinates'],
            radius=sizes[idx % len(sizes)],
            popup=f"{row['comarca']}: {row['assunto']} ({row['count']} processos)",
            color=assunto_to_color[row['assunto']],
            fill=True,
            fill_color=assunto_to_color[row['assunto']]
        ).add_to(group)

# Adicionar o controle de camadas para alternar as visualizações
LayerControl(collapsed=False).add_to(m)

# Adicionar uma legenda no mapa
legend_html = '''
<div style="position: fixed;
     bottom: 50px; left: 50px; width: 150px; height: 90px;
     border:2px solid grey; z-index:9999; font-size:14px;
     ">&nbsp; Legenda <br>
     &nbsp; Círculo = Processo <br>
     &nbsp; Cor = Categoria do Assunto
</div>
'''
m.get_root().html.add_child(folium.Element(legend_html))

# Salvar e mostrar mapa
m.save('interactive_map_with_legend.html')

m

"""## Procurando endereços nas sentenças"""

!pip install spacy
!python -m spacy download pt_core_news_sm

tjsp.head()

import spacy

# Carregar um modelo pré-treinado do spaCy
nlp = spacy.load("pt_core_news_sm")

# Exemplo de texto
texto = "O processo originou-se em São Paulo e requer que o hospital Santa Marcelina cumpra as obrigações."

# Processar o texto
doc = nlp(texto)

# Extrair entidades
enderecos = [ent.text for ent in doc.ents if ent.label_ in ['LOC', 'ORG']]

print(enderecos)

"""Evxpressões regulares (regex) ou bibliotecas de NLP como spaCy com modelos treinados para reconhecimento de entidades nomeadas (Named Entity Recognition, NER) que podem identificar locais."""

import googlemaps

# Configurar cliente do Google Maps
gmaps = googlemaps.Client(key='AIzaSyAvqU8-togmlAdibLlfdz6YpgN5cVD7d54')

# Função para obter coordenadas
def get_coordinates(address):
    geocode_result = gmaps.geocode(address)
    if geocode_result:
        lat = geocode_result[0]['geometry']['location']['lat']
        lng = geocode_result[0]['geometry']['location']['lng']
        return (lat, lng)
    return None

# Exemplo de obtenção de coordenadas
for endereco in enderecos:
    coord = get_coordinates(endereco)
    print(endereco, coord)

"""# Processador de Dados do Fórum de São Paulo

Este script Python é projetado para automatizar a extração e estruturação de informações de registros judiciais do fórum distrital de São Paulo. O script lê um arquivo CSV contendo dados brutos do fórum e separa informações específicas em novos campos estruturados.

## Funcionalidades

O script possui as seguintes funcionalidades:

- **Extrair Informações do Fórum**: Separa dados do campo 'Dados_Fórum' em nome da vara, nome do(a) juiz(a) e nome do(a) escrivão(ã).

- **Extrair Conteúdo do Processo**: Divide o campo 'Conteúdo' em tipo de processo, status, partes envolvidas, manifestação e nomes dos advogados.

- **Salvar Dados Tratados**: Armazena os dados processados em um novo arquivo CSV para facilitar a análise e o manuseio posterior dos dados.

## Uso

Para executar o script, certifique-se de que o arquivo CSV original está no mesmo diretório que o script e que o caminho do arquivo está correto na variável `df`, que pode ser personalizada conforme o caso.

O script pode ser executado com o seguinte comando:

```bash
python sdata_tjsp.py

# Estrutura de Dados

## Campos Originais

###Dados_Fórum: Texto contendo informações sobre a vara, o(a) juiz(a) e o(a) escrivão(ã).

## Conteúdo: Texto detalhando informações sobre o processo, como tipo, status, partes e outras anotações relevantes.

# Campos Extraídos

## Nome da Vara: Nome da vara judicial.
##Nome do Juiz(a): Nome completo do(a) juiz(a) responsável.
##Nome do Escrivão: Nome completo do(a) escrivão(ã) judicial.

##Tipo: Categoria ou tipo do processo.

##Status: Status atual do processo.

##Partes: Nomes das partes envolvidas no processo.

##Manifestação: Descrição ou notas sobre o processo.

##Advogados: Nomes dos advogados relacionados ao caso.

#Requisitos

###Python 3
###Pandas: Uma biblioteca de Python para manipulação de dados e análise.
###Re: Módulo de expressões regulares do Python.
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import re

# Carregar o arquivo CSV
df = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/são_paulo_foro_distrital_de_parelheiros.csv')

# Função para extrair informações do campo "Dados_Fórum"
def extrair_dados_forum(texto):
    # Usar a expressão regular sugerida para capturar a vara, e em seguida remover a palavra "JUIZ"
    nome_vara_match = re.search(r'(\d.+)JUIZ', texto)
    nome_vara = nome_vara_match.group(1).strip() if nome_vara_match else None

    nome_juiz_match = re.search(r'JUIZ\(A\) DE DIREITO (.*?) ESCRIVÃ\(O\)', texto)
    nome_juiz = nome_juiz_match.group(1).strip() if nome_juiz_match else None

    nome_escrivao = texto.split('ESCRIVÃ(O) ')[-1].strip() if 'ESCRIVÃ(O) ' in texto else None

    return nome_vara, nome_juiz, nome_escrivao

# Função para extrair informações do campo "Conteúdo"
def extrair_conteudo(texto):
    partes = texto.split(' - ')
    tipo = partes[1].strip() if len(partes) > 1 else None
    status = partes[2].strip() if len(partes) > 2 else None
    partes_texto = partes[3].strip() if len(partes) > 3 else None

    manifestacao_advogados = ' - '.join(partes[4:]).strip() if len(partes) > 4 else None
    manifestacao = None
    advogados = None
    if manifestacao_advogados:
        manifestacao_match = re.match(r'.+?(?= - ADV:)', manifestacao_advogados)
        manifestacao = manifestacao_match.group(0).strip() if manifestacao_match else manifestacao_advogados
        advogados = manifestacao_advogados.split(' - ADV: ')[-1].strip() if ' - ADV:' in manifestacao_advogados else None

    return tipo, status, partes_texto, manifestacao, advogados

# Aplicar as funções de extração ao DataFrame
df[['Nome da Vara', 'Nome do Juiz(a)', 'Nome do Escrivão']] = df.apply(lambda x: extrair_dados_forum(x['Dados_Fórum']), axis=1, result_type="expand")
df[['Tipo', 'Status', 'Partes', 'Manifestação', 'Advogados']] = df.apply(lambda x: extrair_conteudo(x['Conteúdo']), axis=1, result_type="expand")

# Ajustar o nome da vara para remover a palavra "JUIZ"
df['Nome da Vara'] = df['Nome da Vara'].str.replace('JUIZ', '').str.strip()

# Salvar o DataFrame modificado em um novo arquivo CSV
df.to_csv('/content/drive/MyDrive/pos_doc_usp/dados_tratatos/são_paulo_foro_distrital_de_parelheiros_tratado.csv', index=False)

df

"""
```markdown
# Atualizações do Processador de Dados do Fórum de São Paulo

 As atualizações focam em melhorar a identificação e filtragem de casos relacionados a tratamentos de saúde, com ênfase em condições de câncer, e em rastrear a movimentação processual de processos individuais.

## Novas Funcionalidades

- **Identificação de Casos Relacionados a Saúde**:

O script foi aprimorado para identificar registros que mencionam termos específicos relacionados a tratamentos de saúde, condições de câncer, medicamentos e procedimentos. Isso é feito através da busca por palavras-chave específicas dentro do campo 'Conteúdo'.

- **Rastreamento de Movimentações Processuais**:

O script extrai o número do processo de cada registro e organiza as movimentações processuais por número de processo. Isso permite rastrear a história completa de cada caso do início ao fim.

- **Atualização da Lista de Palavras-chave**:

Uma lista abrangente de palavras-chave foi adicionada ao script para capturar uma gama mais ampla de processos relacionados a saúde. Essas palavras-chave incluem termos médicos específicos, nomes de medicamentos e procedimentos associados ao tratamento do câncer.

## Uso Atualizado

Após a execução, o script agora gera dois conjuntos de dados:

1. `df_saude.csv`: Contém registros filtrados que estão relacionados a questões de saúde conforme identificado pelas palavras-chave.

2. `movimentacoes_por_processo`: Uma coleção de registros organizados por número processual que podem ser consultados para revisão de casos individuais e suas histórias processuais.

## Instruções para Adição de Palavras-chave

Caso seja necessário adicionar mais palavras-chave relacionadas a saúde, os termos devem ser incluídos na lista de palavras-chave da seguinte maneira:

```python
# Adicionar palavras-chave à lista existente
palavras_chave_saude.extend(['nova_palavra1', 'nova_palavra2', ...])
```



## Execução do Script

Certifique-se de que o arquivo CSV de entrada está no diretório correto e execute o script com o comando:

```bash
python sdata_tjsp.py
```

## Notas Adicionais

A precisão do filtro de saúde depende da qualidade dos dados e da abrangência das palavras-chave utilizadas. Realizado a partir de análise morfossintatico e de dicionários de equivalencia (BARBOSA, 2022) Testes adicionais podem ser necessários para garantir que todos os casos relevantes sejam capturados.
```"""

import pandas as pd
import re

# Carregar o arquivo CSV
df = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/dados_tratatos/são_paulo_foro_distrital_de_parelheiros_tratado.csv')

# Palavras-chave para buscar registros relacionados à saúde, especificamente câncer e tratamentos relacionados
palavras_chave_saude = [
    "tratamento câncer", "tumor maligno", "tratamento de neoplasia", "direito a assistência médica",
    "internação hospitalar", "direito a saúde", "tratamento de doença", "sistema único de saúde",
    "medicamento câncer", "cirurgia câncer", "medicamento para neoplasia", "artigo 196 constituição",
    "atendimentos pelo sus", "direito a assistência farmacêutica", "registro na anvisa",
    "medicamentos de alto custo", "câncer", "cancerígeno", "quimioterapia", "radioterapia",
    "metástase", "abraxane", "acalabrutinibe", "acetato de abiraterona","sus",
    "medicamento cancer", "cirurgia cancer", "medicamento para neoplasia", "constituição artigo 196",
    "atendimentos pelo sus", "direito a assistencia farmaceutica", "registro na anvisa",
    "medicamentos de alto custo", "quimioterap", "radioterap",
    "acetato de gosserrelina", "acetato de leuprorrelina",
    "acetato de megestrol", "acido zoledronico", "adcetris", "afinitor", "alimta",
    "anastrozol", "arimidex", "avastin", "bevacizumabe", "bortezomibe", "capecitabina",
    "carboplatina", "cetuximabe", "cisplatina", "dacarbazina", "dasatinibe", "denosumabe",
    "docetaxel", "erbitux", "gemzar", "gefitinibe"


    # ... (continuar a lista completa)
]

# Função para verificar se o conteúdo contém alguma das palavras-chave relacionadas à saúde
def contem_palavras_saude(texto):
    texto = texto.lower()
    for palavra in palavras_chave_saude:
        if re.search(r'\b' + re.escape(palavra) + r'\b', texto):
            return True
    return False

# Aplicar a função para filtrar os registros relacionados à saúde
df['Relacionado_Saude'] = df['Conteúdo'].apply(contem_palavras_saude)

# Separar os registros relacionados à saúde em um novo DataFrame
df_saude = df[df['Relacionado_Saude']]

# Extrair o número do processo para rastreamento
df['Numero_Processual'] = df['Conteúdo'].str.extract(r'Processo (\d+-\d+.\d+.\d+.\d+)')

# Agrupar as movimentações por número processual
movimentacoes_por_processo = df.groupby('Numero_Processual')

# Para demonstração, vamos imprimir as movimentações de um número processual específico
numero_processual_exemplo = df['Numero_Processual'].iloc[0]
movimentacoes_exemplo = movimentacoes_por_processo.get_group(numero_processual_exemplo).sort_values(by='Data')

print(f"Mostrando movimentações para o processo número: {numero_processual_exemplo}")
print(movimentacoes_exemplo[['Data', 'Conteúdo']])

# Salvar os dados relacionados à saúde e as movimentações processuais
df_saude.to_csv('/content/drive/MyDrive/pos_doc_usp/dados_tratatos/são_paulo_foro_distrital_de_parelheiros_tratado.csv', index=False)

import json

# Dados em formato de string JSON como você forneceu
dados_json = '''
{"tratamento cancer": 0, "tumor maligno": 0, "tratamento de neoplasia": 0, "direito a assitencia medica": 0, "internacao hospitalar": 0, "direito a saude": 0, "tratamento": 0, "sistema unico de saude": 0, "medicamento cancer": 0, "cirurgia cancer": 0, "medicamento para neoplasia": 0, "artigo 196": 0, "atendimentos pelo sus": 0, "direito a assistencia farmaceutica": 0, "registro na anvisa": 0, "medicamentos de alto custo": 0, "cancer": 0, "cancerigeno": 0, "quimioterap": 0, "radioterap": 0, "quimioterapia": 0, "quimioterapico": 0, "quimioterapica": 0, "radioterapia": 0, "radioterapico": 0, "radioterapica": 0, "metastase": 0, "abraxane": 0, "acalabrutinibe": 0, "acetato de abiraterona": 0, "acetato de gosserrelina": 0, "acetato de leuprorrelina": 0, "acetato de megestrol": 0, "acido zoledronico": 0, "adcetris": 0, "adriblastina": 0, "afinitor": 0, "aflibercepte": 0, "agrylin": 0, "akssus": 0, "alecensa": 0, "alfainterferona 2a": 0, "alimta": 0, "alkeran": 0, "alpelisibe": 0, "amifostina": 0, "anastrol": 0, "anastrolibbs": 0, "anastrozol": 0, "anya": 0, "apalutamida": 0, "arazabi": 0, "arimidex": 0, "aromasin": 0, "asparaginase": 0, "atezolizumabe": 0, "atobach": 0, "atred": 0, "avastin": 0, "avelumabe": 0, "axitinibe": 0, "azacitidina": 0, "balefio": 0, "baricitinibe": 0, "bavencio": 0, "beleodaq": 0, "belinostate": 0, "besponsa": 0, "bevacizumabe": 0, "bicalutamida": 0, "blinatumomabe": 0, "blincyto": 0, "bonar": 0, "bortezomibe": 0, "bortyz": 0, "bozored": 0, "b -platin": 0, "brecila": 0, "brentuximabe vedotina": 0, "brigatinibe": 0, "busilvex": 0, "bussulfano": 0, "bycal": 0, "caab": 0, "cabazitaxel": 0, "cabazred": 0, "caelyx": 0, "calquence": 0, "camptosar": 0, "camptrix": 0, "capecare": 0, "capecitabina": 0, "capeliv": 0, "caprelsa": 0, "carboplatina": 0, "carfilzomibe": 0, "carmustina": 0, "casodex": 0, "cemiplimabe": 0, "cetuximabe": 0, "ciclofosfamida monoidratada": 0, "cimaher": 0, "cinaleo": 0, "cisplatina": 0, "citoplatina": 0, "citoplax": 0, "citostina": 0, "citrato de ixazomibe": 0, "citrato de tamoxifeno": 0, "cladribina": 0, "clorambucila": 0, "cloreto de radio (223 ra)": 0, "cloridrato de alectinibe": 0, "cloridrato de aminolevulinato de metila": 0, "cloridrato de anagrelida": 0, "cloridrato de bendamustina": 0, "cloridrato de daunorrubicina": 0, "cloridrato de doxorrubicina": 0, "cloridrato de epirrubicina": 0, "cloridrato de erlotinibe": 0, "cloridrato de gencitabina": 0, "cloridrato de idarrubicina": 0, "cloridrato de irinotecana": 0, "cloridrato de irinotecano": 0, "cloridrato de irinotecano tri-hidratado": 0, "cloridrato de irinotecano triidratado": 0, "cloridrato de mitoxantrona": 0, "cloridrato de pazopanibe": 0, "cloridrato de ponatinibe": 0, "cloridrato de tipiracila, trifluridina": 0, "cloridrato de topotecana": 0, "cloritecan": 0, "coama": 0, "collectro": 0, "corretal": 0, "cotellic\u00ae": 0, "c-platin": 0, "crizotinibe": 0, "cropoc": 0, "cyramza": 0, "cytogem": 0, "dabaz": 0, "dacarb": 0, "dacarbazina": 0, "dacogen": 0, "dasatinibe": 0, "daunoblastina": 0, "decitabina": 0, "denosumabe": 0, "densis": 0, "dimaleato de afatinibe": 0, "dimetilsulfoxido de trametinibe": 0, "ditartarato de vinorelbina": 0, "ditosilato de lapatinibe": 0, "doceglennu": 0, "docelibbs": 0, "docetaxel": 0, "docetaxel tri-hidratado": 0, "docetaxel triidratado": 0, "doceuno": 0, "docks": 0, "dosataxel": 0, "doxopeg": 0, "dronik": 0, "dti": 0, "efurix": 0, "eligard": 0, "elotuzumabe": 0, "emah": 0, "empliciti": 0, "emtaz": 0, "enzalutamida": 0, "eposido": 0, "eranful": 0, "erbitux": 0, "erdafitinibe": 0, "erfandel": 0, "erivedge": 0, "erleada": 0, "eroxym": 0, "esilato de nintedanibe": 0, "etopos": 0, "etoposideo": 0, "etoposido": 0, "eunades cs": 0, "everolimo": 0, "evobrig": 0, "evocarb": 0, "evoclass": 0, "evodazin": 0, "evoflubina": 0, "evolox": 0, "evomid": 0, "evomixan": 0, "evoposdo": 0, "evorubicin": 0, "evotabina": 0, "evotaxel": 0, "evotecan": 0, "evoterin": 0, "evozar": 0, "exemestano": 0, "exher": 0, "farmorubicina": 0, "faslodex": 0, "faulblastina": 0, "fauldacar": 0, "fauldcarbo": 0, "fauldcispla": 0, "fauldoxo": 0, "fauldpami": 0, "fauldvincri": 0, "femara": 0, "femigestrol": 0, "fluoruracila": 0, "flusan": 0, "flutamid": 0, "flutamida": 0, "fonhep": 0, "fosfato de fludarabina": 0, "fosfato de ruxolitinibe": 0, "fotemustina": 0, "fulvestranto": 0, "gazyva": 0, "gcib": 0, "gefitinibe": 0, "gemcired": 0, "gemcit": 0, "gemzar": 0, "gencitabina": 0}'''

# Converter a string JSON em um dicionário Python
termos_saude_dict = json.loads(dados_json)

# Extrair apenas as chaves do dicionário, que são os termos de interesse
palavras_chave_saude = list(termos_saude_dict.keys())

# Agora você pode usar a variável palavras_chave_saude em seu script para filtrar os dados

print(palavras_chave_saude)

import pandas as pd
import re

# Carregar o arquivo CSV
df = pd.read_csv('/content/drive/MyDrive/pos_doc_usp/dados_tratatos/são_paulo_foro_distrital_de_parelheiros_tratado.csv')

# Palavras-chave atualizadas para buscar registros relacionados à saúde
palavras_chave_saude = [
    "tratamento cancer", "tumor maligno", "tratamento de neoplasia", "direito a assistencia medica",
    "internacao hospitalar", "direito a saude", "tratamento", "sistema unico de saude",
    "medicamento cancer", "cirurgia cancer", "medicamento para neoplasia", "artigo 196",
    "atendimentos pelo sus", "direito a assistencia farmaceutica", "registro na anvisa",
    "medicamentos de alto custo", "cancer", "cancerigeno", "quimioterap", "radioterap",
    "quimioterapia", "radioterapia", "metastase", "abraxane", "acalabrutinibe",
    "acetato de abiraterona", "acetato de gosserrelina", "acetato de leuprorrelina",
    "acetato de megestrol", "acido zoledronico", "adcetris", "afinitor", "alimta",
    "anastrozol", "arimidex", "avastin", "bevacizumabe", "bortezomibe", "capecitabina",
    "carboplatina", "cetuximabe", "cisplatina", "dacarbazina", "dasatinibe", "denosumabe",
    "docetaxel", "erbitux", "gemzar", "gefitinibe",'metastase', 'abraxane', 'acalabrutinibe', 'acetato de abiraterona', 'acetato de gosserrelina', 'acetato de leuprorrelina', 'acetato de megestrol', 'acido zoledronico', 'adcetris', 'adriblastina', 'afinitor', 'aflibercepte', 'agrylin', 'akssus', 'alecensa',
    'alfainterferona 2a', 'alimta', 'alkeran', 'alpelisibe', 'amifostina', 'anastrol', 'anastrolibbs',
    'anastrozol', 'anya', 'apalutamida', 'arazabi', 'arimidex', 'aromasin', 'asparaginase', 'atezolizumabe',
    'atobach', 'atred', 'avastin', 'avelumabe', 'axitinibe', 'azacitidina', 'balefio', 'baricitinibe',
    'bavencio', 'beleodaq', 'belinostate', 'besponsa', 'bevacizumabe', 'bicalutamida', 'blinatumomabe',
    'blincyto', 'bonar', 'bortezomibe', 'bortyz', 'bozored', 'b -platin', 'brecila', 'brentuximabe vedotina',
    'brigatinibe', 'busilvex', 'bussulfano', 'bycal', 'caab', 'cabazitaxel', 'cabazred', 'caelyx', 'calquence', 'camptosar',
    'camptrix', 'capecare', 'capecitabina', 'capeliv', 'caprelsa', 'carboplatina', 'carfilzomibe', 'carmustina', 'casodex',
    'cemiplimabe', 'cetuximabe', 'ciclofosfamida monoidratada', 'cimaher', 'cinaleo', 'cisplatina', 'citoplatina', 'citoplax',
    'citostina', 'citrato de ixazomibe', 'citrato de tamoxifeno', 'cladribina', 'clorambucila', 'cloreto de radio (223 ra)',
    'cloridrato de alectinibe', 'cloridrato de aminolevulinato de metila', 'cloridrato de anagrelida', 'cloridrato de bendamustina',
    'cloridrato de daunorrubicina', 'cloridrato de doxorrubicina', 'cloridrato de epirrubicina', 'cloridrato de erlotinibe',
    'cloridrato de gencitabina', 'cloridrato de idarrubicina', 'cloridrato de irinotecana', 'cloridrato de irinotecano',
    'cloridrato de irinotecano tri-hidratado', 'cloridrato de irinotecano triidratado', 'cloridrato de mitoxantrona',
    'cloridrato de pazopanibe', 'cloridrato de ponatinibe', 'cloridrato de tipiracila, trifluridina', 'cloridrato de topotecana',
    'cloritecan', 'coama', 'collectro', 'corretal', 'cotellic®', 'c-platin', 'crizotinibe', 'cropoc', 'cyramza', 'cytogem', 'dabaz', 'dacarb', 'dacarbazina',
    'dacogen', 'dasatinibe', 'daunoblastina', 'decitabina', 'denosumabe', 'densis', 'dimaleato de afatinibe', 'dimetilsulfoxido de trametinibe', 'ditartarato de vinorelbina',
    'ditosilato de lapatinibe', 'doceglennu', 'docelibbs', 'docetaxel', 'docetaxel tri-hidratado', 'docetaxel triidratado', 'doceuno', 'docks', 'dosataxel', 'doxopeg',
    'dronik', 'dti', 'efurix', 'eligard', 'elotuzumabe', 'emah', 'empliciti', 'emtaz', 'enzalutamida', 'eposido', 'eranful', 'erbitux', 'erdafitinibe', 'erfandel',
    'erivedge', 'erleada', 'eroxym', 'esilato de nintedanibe', 'etopos', 'etoposideo', 'etoposido', 'eunades cs', 'everolimo', 'evobrig', 'evocarb', 'evoclass', 'evodazin',
    'evoflubina', 'evolox', 'evomid', 'evomixan', 'evoposdo', 'evorubicin', 'evotabina', 'evotaxel', 'evotecan', 'evoterin', 'evozar', 'exemestano', 'exher', 'farmorubicina',
    'faslodex', 'faulblastina', 'fauldacar', 'fauldcarbo', 'fauldcispla', 'fauldoxo', 'fauldpami', 'fauldvincri', 'femara', 'femigestrol', 'fluoruracila', 'flusan',
    'flutamid', 'flutamida', 'fonhep', 'fosfato de fludarabina', 'fosfato de ruxolitinibe', 'fotemustina', 'fulvestranto', 'gazyva', 'gcib', 'gefitinibe', 'gemcired',
    'gemcit', 'gemzar', 'gencitabina']

# Função para verificar se o conteúdo contém alguma das palavras-chave relacionadas à saúde
def contem_palavras_saude(texto):
    texto = texto.lower()
    for palavra in palavras_chave_saude:
        if re.search(r'\b' + re.escape(palavra) + r'\b', texto):
            return True
    return False

# filtra os registros relacionados à saúde
df['Relacionado_Saude'] = df['Conteúdo'].apply(contem_palavras_saude)

# Separa os registros relacionados à saúde em um novo DataFrame
df_saude = df[df['Relacionado_Saude']]

# Extrai o número do processo para rastreamento
df['Numero_Processual'] = df['Conteúdo'].str.extract(r'Processo (\d+-\d+.\d+.\d+.\d+)')

# Agrupa as movimentações por número processual
movimentacoes_por_processo = df.groupby('Numero_Processual')

# Para demonstração, imprimi as movimentações de um número processual específico

numero_processual_exemplo = df['Numero_Processual'].iloc[0]
movimentacoes_exemplo = movimentacoes_por_processo.get_group(numero_processual_exemplo).sort_values(by='Data')

print(f"Mostrando movimentações para o processo número: {numero_processual_exemplo}")
print(movimentacoes_exemplo[['Data', 'Conteúdo']])

# Salva os dados relacionados à saúde e as movimentações processuais
df_saude.to_csv('/content/drive/MyDrive/pos_doc_usp/dados_tratatos/são_paulo_foro_distrital_de_parelheiros_verificado_cancer.csv', index=False)

# Supondo que df_saude seja o seu DataFrame e que ele tenha as colunas "Conteúdo" e "Relacionado_Saude"

# Filtrar as linhas onde "Relacionado_Saude" é True
registros_saude = df_saude[df_saude['Relacionado_Saude'] == True]

# Exibir algumas linhas da coluna "Conteúdo" desses registros
print(registros_saude['Conteúdo'].head())

# Supondo que 'df' seja o seu DataFrame
#linha_especifica = df['Conteúdo'].iloc[756]
#print(linha_especifica)

"""# Script realiza uma busca por datas e termos relacionados a liminares ou tutelas antecipadas dentro do texto das movimentações processuais."""

print(df_saude)

import pandas as pd

# Supondo que df seja o seu DataFrame e 'Data' a coluna com as datas a serem tratadas

# Função para tratar e converter a data
def converter_data(data):
    # Extraindo os últimos 9 dígitos
    data_str = str(data)
    data_formatada = data_str[-9:]

    # Reformatando para DD/MM/YYYY
    ano = data_formatada[0:4]
    mes = data_formatada[4:6]
    dia = data_formatada[6:8]

    # Juntando os componentes no novo formato
    nova_data = f"{dia}/{mes}/{ano}"

    return nova_data

# Aplicando a função de conversão na coluna 'Data'
df_saude['Data'] = df_saude['Data'].apply(converter_data)

# Convertendo a coluna 'Data' para o tipo datetime
df_saude['Data'] = pd.to_datetime(df_saude['Data'], format='%d/%m/%Y')

# Exibindo as primeiras linhas para verificar o resultado
print(df_saude.head())

# Agrupando os processos no df_saude pelo campo "Processo"
processos_saude = df_saude['Processo'].unique()
# Consultando e separando os processos no DF
df_saude_processos = df[df['Processo'].isin(processos_saude)]

# Convertendo a coluna 'Data' para datetime
df_saude_processos['Data'] = pd.to_datetime(df_saude_processos['Data'])

# Calculando a data de início e fim para cada processo
df_saude_processos_agrupados = df_saude_processos.groupby('Processo').agg(Data_Inicio=('Data', 'min'), Data_Fim=('Data', 'max'))

# Calculando a duração dos processos
df_saude_processos_agrupados['Duracao'] = (df_saude_processos_agrupados['Data_Fim'] - df_saude_processos_agrupados['Data_Inicio']).dt.days

# Calculando a média do tempo dos processos
media_tempo = df_saude_processos_agrupados['Duracao'].mean()

# Identificando os 10 processos com maior tempo
top_10_processos = df_saude_processos_agrupados.nlargest(10, 'Duracao')

top_10_processos

from matplotlib import pyplot as plt
top_10_processos['Duracao'].plot(kind='hist', bins=20, title='Duracao')
plt.gca().spines[['top', 'right',]].set_visible(False)

# Agrupando por mês/ano
df_saude_processos['AnoMes'] = df_saude_processos['Data'].dt.to_period('M')
processos_por_mes_ano = df_saude_processos.groupby('AnoMes').size()

# Plotando
processos_por_mes_ano.plot(kind='bar', figsize=(10, 6), color='skyblue')
plt.title('Processos por Mês/Ano')
plt.xlabel('Mês/Ano')
plt.ylabel('Quantidade de Processos')
plt.xticks(rotation=45)
plt.show()

# 'Tipo' e 'Status' sejam colunas no df_saude_processos
tipo_contagem = df_saude_processos['Tipo'].value_counts()
status_contagem = df_saude_processos['Status'].value_counts()

# Plotando Tipo
tipo_contagem.plot(kind='bar', figsize=(10, 6), color='orange')
plt.title('Quantidade de Processos por Tipo')
plt.xlabel('Tipo')
plt.ylabel('Quantidade')
plt.show()

# Plotando Status
status_contagem.plot(kind='bar', figsize=(10, 6), color='green')
plt.title('Quantidade de Processos por Status')
plt.xlabel('Status')
plt.ylabel('Quantidade')
plt.show()

# Supondo que a coluna 'Advogados' contenha os nomes dos advogados separados por vírgula
# Vamos primeiro expandir essa coluna para contar cada advogado separadamente
advogados_expandidos = df_saude_processos['Advogados'].str.split(', ', expand=True).stack()
advogados_contagem = advogados_expandidos.value_counts()

# Mostrando os advogados mais frequentes
advogados_contagem.head(10).plot(kind='bar', figsize=(10, 6), color='purple')
plt.title('Top 10 Advogados por Quantidade de Processos')
plt.xlabel('Advogado')
plt.ylabel('Quantidade de Processos')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Convertendo 'Data' para datetime, se ainda não foi convertido
df_saude_processos['Data'] = pd.to_datetime(df_saude_processos['Data'])

# Calculando o tempo de cada processo
df_saude_processos['Tempo_Processual'] = df_saude_processos.groupby('Processo')['Data'].transform(lambda x: (x.max() - x.min()).days)

# Calculando a quantidade de movimentações por processo
df_saude_processos['Quantidade_Movimentacoes'] = df_saude_processos.groupby('Processo')['Processo'].transform('count')

# Tempo médio e quantidade média de movimentações por processo
tempo_medio_por_processo = df_saude_processos.groupby('Processo')['Tempo_Processual'].mean()
qtd_media_mov_por_processo = df_saude_processos.groupby('Processo')['Quantidade_Movimentacoes'].mean()

# Plotando o tempo médio de cada processo
tempo_medio_por_processo.sort_values(ascending=False).head(10).plot(kind='bar', figsize=(10, 6), color='skyblue')
plt.title('Top 10 Processos com Maior Tempo Médio')
plt.xlabel('Processo')
plt.ylabel('Tempo Médio (dias)')
plt.show()

# Plotando a quantidade média de movimentações por processo
qtd_media_mov_por_processo.sort_values(ascending=False).head(10).plot(kind='bar', figsize=(10, 6), color='orange')
plt.title('Top 10 Processos com Maior Quantidade Média de Movimentações')
plt.xlabel('Processo')
plt.ylabel('Quantidade Média de Movimentações')
plt.show()

# Supondo 'Tipo' como exemplo de coluna para contagem
top_10_tipos = df_saude_processos['Tipo'].value_counts().head(10)

# Plotando os 10 maiores 'Tipo'
top_10_tipos.plot(kind='bar', figsize=(10, 6), color='green')
plt.title('Top 10 Tipos de Processo')
plt.xlabel('Tipo')
plt.ylabel('Quantidade')
plt.show()

# Repetir o processo para outras colunas como 'Status', 'Advogados', etc.

# Lista de números de processos desejados
numeros_processos_desejados = ['0001619-80.2010.8.26.0012']

# Realizando a busca no DataFrame
processos_encontrados = df[df['Dados_Fórum'].isin(numeros_processos_desejados)]

# Exibindo o resultado da busca
print(processos_encontrados)

import pandas as pd
import matplotlib.pyplot as plt
import re
from collections import Counter

# Adota a variável df como DataFrame com os dados, e 'Conteúdo' a coluna com as informações textuais mesmo
# já tenha sido tratada em outras variáveis

# Função para extrair datas das movimentações
def extrair_datas(texto):
    # Exemplo de padrão de data: 01/01/2020 ou 01-01-2020
    datas = re.findall(r'\b\d{2}[/-]\d{2}[/-]\d{4}\b', texto)
    return datas

# Função para verificar a presença de liminares ou tutelas antecipadas
def verificar_liminar_tutela(texto):
    if re.search(r'liminar|tutela antecipada', texto, re.IGNORECASE):
        return True
    return False

# Aplicando as funções ao DataFrame
df['Datas'] = df['Conteúdo'].apply(extrair_datas)
df['Liminar_Tutela'] = df['Conteúdo'].apply(verificar_liminar_tutela)

# Contando ocorrências de liminares ou tutelas antecipadas
quantidade_liminar_tutela = df['Liminar_Tutela'].sum()

# Representação gráfica da quantidade de liminares ou tutelas antecipadas
plt.figure(figsize=(6, 4))
plt.bar(['Liminares/Tutelas Antecipadas'], [quantidade_liminar_tutela], color='skyblue')
plt.title('Quantidade de Liminares ou Tutelas Antecipadas')
plt.ylabel('Quantidade')
plt.show()

# Extrair e contar anos das datas para visualizar a distribuição ao longo do tempo
anos = []
for lista_datas in df['Datas']:
    anos.extend([re.search(r'\d{4}', data).group() for data in lista_datas])
contador_anos = Counter(anos)

# Gráfico da distribuição de movimentações ao longo dos anos
plt.figure(figsize=(10, 6))
plt.bar(contador_anos.keys(), contador_anos.values(), color='lightgreen')
plt.title('Distribuição de Movimentações por Ano')
plt.xlabel('Ano')
plt.ylabel('Quantidade de Movimentações')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()